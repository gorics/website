<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <title>지렁이 게임</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(16px, 5vw, 48px);
            background: linear-gradient(135deg, #09203f 0%, #537895 100%);
            color: #ecf0f1;
            font-family: 'Pretendard', 'Noto Sans KR', system-ui, sans-serif;
        }
        .panel {
            width: min(100%, 460px);
            text-align: center;
            background: rgba(9, 32, 63, 0.85);
            padding: clamp(22px, 5vw, 36px);
            border-radius: 22px;
            box-shadow: 0 18px 35px rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: grid;
            gap: 16px;
            justify-items: center;
        }
        canvas {
            background: #04101f;
            border-radius: 16px;
            border: 6px solid rgba(255, 255, 255, 0.08);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            width: min(100%, 420px);
            height: auto;
        }
        h1 {
            margin: 0;
            letter-spacing: 2px;
            font-size: clamp(24px, 5vw, 32px);
        }
        .signature {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(26, 188, 156, 0.18);
            color: #1abc9c;
            font-weight: 700;
            font-size: 13px;
        }
        .score {
            margin: 0;
            font-size: clamp(18px, 4vw, 22px);
            font-weight: 600;
        }
        .hint {
            margin: 0;
            color: rgba(255, 255, 255, 0.72);
            font-size: clamp(13px, 3.2vw, 15px);
            line-height: 1.6;
        }
        button {
            background: #1abc9c;
            color: #04101f;
            border: none;
            border-radius: 999px;
            padding: 12px clamp(22px, 6vw, 32px);
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 15px;
        }
        button:hover, button:focus-visible {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(26, 188, 156, 0.35);
            outline: none;
        }
        @media (max-width: 480px) {
            canvas {
                border-width: 4px;
            }
        }
    </style>
</head>
<body>
    <div class="panel">
        <div class="signature">박은성이 만든 게임</div>
        <h1>지렁이 게임</h1>
        <div class="score">점수: <span id="score">0</span></div>
        <canvas id="board" width="400" height="400" data-gesture-input="arrows"></canvas>
        <button id="restart">다시 시작</button>
        <p class="hint">방향키, 화면 탭/스와이프, 온스크린 패드 모두로 조작할 수 있어요. 벽이나 몸에 부딪히면 게임이 종료됩니다.</p>
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        const scoreEl = document.getElementById('score');
        const restartBtn = document.getElementById('restart');

        let snake, direction, food, score, speed, frameId;

        function init() {
            snake = [
                { x: 9, y: 10 },
                { x: 8, y: 10 },
                { x: 7, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            score = 0;
            speed = 150;
            placeFood();
            updateScore();
            if (frameId) cancelAnimationFrame(frameId);
            loop();
        }

        function placeFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            } while (snake.some(part => part.x === food.x && part.y === food.y));
        }

        function updateScore() {
            scoreEl.textContent = score;
        }

        let lastRender = 0;
        function loop(timestamp = 0) {
            frameId = requestAnimationFrame(loop);
            if (timestamp - lastRender < speed) return;
            lastRender = timestamp;

            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            if (head.x < 0) head.x = tileCount - 1;
            if (head.y < 0) head.y = tileCount - 1;
            if (head.x >= tileCount) head.x = 0;
            if (head.y >= tileCount) head.y = 0;

            if (snake.some(part => part.x === head.x && part.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                speed = Math.max(60, speed - 5);
                placeFood();
                updateScore();
            } else {
                snake.pop();
            }

            draw();
        }

        function draw() {
            ctx.fillStyle = '#020811';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ff5252';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff5252aa';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
            ctx.shadowBlur = 0;

            snake.forEach((segment, index) => {
                const t = index / snake.length;
                const hue = 150 + t * 120;
                ctx.fillStyle = `hsl(${hue}, 70%, ${60 - t * 20}%)`;
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
            });
        }

        function gameOver() {
            cancelAnimationFrame(frameId);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ecf0f1';
            ctx.font = '28px Pretendard, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('게임 오버!', canvas.width / 2, canvas.height / 2 - 10);
            ctx.font = '18px Pretendard, sans-serif';
            ctx.fillText('다시 시작 버튼을 눌러 재도전하세요.', canvas.width / 2, canvas.height / 2 + 24);
        }

        function setDirection(nx, ny) {
            if (direction.x === nx && direction.y === ny) return;
            if (direction.x === -nx && direction.y === -ny) return;
            direction = { x: nx, y: ny };
        }

        window.addEventListener('keydown', (e) => {
            const { key } = e;
            if (key === 'ArrowUp') setDirection(0, -1);
            else if (key === 'ArrowDown') setDirection(0, 1);
            else if (key === 'ArrowLeft') setDirection(-1, 0);
            else if (key === 'ArrowRight') setDirection(1, 0);
        });

        const pointerState = { active: false, startX: 0, startY: 0 };

        canvas.addEventListener('pointerdown', (e) => {
            if (e.pointerType !== 'mouse') e.preventDefault();
            pointerState.active = true;
            pointerState.startX = e.clientX;
            pointerState.startY = e.clientY;
            canvas.setPointerCapture?.(e.pointerId);
        });

        function finishPointer(e) {
            if (!pointerState.active) return;
            pointerState.active = false;
            canvas.releasePointerCapture?.(e.pointerId);
            const dx = e.clientX - pointerState.startX;
            const dy = e.clientY - pointerState.startY;
            const threshold = 18;
            if (Math.abs(dx) > threshold || Math.abs(dy) > threshold) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    setDirection(dx > 0 ? 1 : -1, 0);
                } else {
                    setDirection(0, dy > 0 ? 1 : -1);
                }
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const tapX = e.clientX - rect.left;
            const tapY = e.clientY - rect.top;
            const head = snake[0];
            if (!head) return;
            const headX = head.x * gridSize + gridSize / 2;
            const headY = head.y * gridSize + gridSize / 2;
            const diffX = tapX - headX;
            const diffY = tapY - headY;
            if (Math.abs(diffX) > Math.abs(diffY)) {
                setDirection(diffX > 0 ? 1 : -1, 0);
            } else {
                setDirection(0, diffY > 0 ? 1 : -1);
            }
        }

        canvas.addEventListener('pointerup', finishPointer);
        canvas.addEventListener('pointercancel', finishPointer);

        canvas.addEventListener('gesturestart', e => e.preventDefault());

        restartBtn.addEventListener('click', init);

        init();
    </script>
    <script src="../global-enhancements.js" defer></script>
</body>
</html>
