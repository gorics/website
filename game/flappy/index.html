<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <title>플래피 비행</title>
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            margin: 0;
            min-height: 100vh;
            display: grid;
            place-items: center;
            padding: clamp(16px, 5vw, 48px);
            background: linear-gradient(180deg, #0f2027, #203a43, #2c5364);
            color: #f5f6fa;
            font-family: 'Pretendard', 'Noto Sans KR', system-ui, sans-serif;
        }
        .container {
            background: rgba(10, 25, 36, 0.88);
            padding: clamp(22px, 5vw, 34px);
            border-radius: clamp(20px, 4vw, 28px);
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 18px;
            align-items: center;
            width: min(100%, 520px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        canvas {
            border-radius: 18px;
            border: 6px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, #3c73d3 0%, #5ad0ff 40%, #98e4ff 60%, #fefefe 100%);
            width: min(100%, 420px);
            height: auto;
        }
        .stats {
            display: flex;
            gap: clamp(12px, 4vw, 20px);
            font-weight: 600;
            flex-wrap: wrap;
            justify-content: center;
        }
        .signature {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(255, 204, 51, 0.16);
            color: #ffe07d;
            font-weight: 700;
            font-size: 13px;
        }
        button {
            background: linear-gradient(135deg, #ffb347, #ffcc33);
            color: #1f2933;
            border: none;
            padding: 10px 24px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 700;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        button:hover, button:focus-visible {
            transform: translateY(-2px);
            box-shadow: 0 18px 26px rgba(255, 204, 51, 0.35);
            outline: none;
        }
        p {
            margin: 0;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.6;
        }
    </style>
    <style>
      :root { --osc-gap: 10px; --osc-btn: 56px; --osc-z: 9999; }
      .credit-banner{
        position:fixed; top:env(safe-area-inset-top,0); left:env(safe-area-inset-left,0);
        margin:8px; padding:6px 10px; font:600 14px/1.2 system-ui, sans-serif;
        background:rgba(0,0,0,.55); color:#fff; border-radius:8px; z-index:var(--osc-z);
        -webkit-backdrop-filter:saturate(150%) blur(6px); backdrop-filter:saturate(150%) blur(6px);
        user-select:none; pointer-events:none;
      }
      .osc-wrap{
        position:fixed; inset:auto 0 env(safe-area-inset-bottom,0) 0;
        display:flex; justify-content:center; gap:24px; padding:var(--osc-gap);
        z-index:var(--osc-z); touch-action:manipulation;
        opacity:0; transform:translateY(18px);
        transition:opacity .28s ease, transform .28s ease;
      }
      .osc-wrap.is-active{ opacity:1; transform:translateY(0); }
      .osc { display:flex; align-items:center; gap:16px; }
      .osc .dpad{ display:grid; grid-template-areas:
          ".    up    ."
          "left  mid  right"
          ".   down   .";
        gap:8px; align-items:center; justify-items:center;
      }
      .osc .actions{ display:flex; gap:10px; }
      .osc button{
        min-width:var(--osc-btn); min-height:var(--osc-btn);
        border:0; border-radius:12px; font:700 16px system-ui, sans-serif;
        background:rgba(255,255,255,.9); color:#111; box-shadow:0 2px 10px rgba(0,0,0,.2);
        transition:transform .16s ease, background-color .16s ease, box-shadow .16s ease;
        user-select:none; touch-action:none;
      }
      .osc button.is-pressed,
      .osc button:active{
        transform:scale(.94);
        background:rgba(255,255,255,.82);
        box-shadow:0 1px 6px rgba(0,0,0,.25);
      }
      .osc .pause{ min-width:72px; }
      /* 게임 화면 가려짐 방지 */
      body{ padding-bottom: calc(env(safe-area-inset-bottom,0) + 110px); }
      @media (pointer:fine){ /* 데스크톱이면 패드 숨김 */
        .osc-wrap{ display:none; } body{ padding-bottom:0; }
      }
      @media (prefers-reduced-motion: reduce){
        .osc-wrap{ transition:none; }
        .osc button{ transition:none; }
      }
    </style>
</head>
<body>
    <div class="container">
        <div class="signature">박은성이 만든 게임</div>
        <h1 style="margin:0;font-size:clamp(24px,5vw,30px);letter-spacing:1px;">플래피 비행</h1>
        <div class="stats">
            <div>점수: <span id="score">0</span></div>
            <div>최고: <span id="best">0</span></div>
        </div>
        <canvas id="game" width="420" height="560"></canvas>
        <button id="restart">다시 시작</button>
        <p>탭/클릭 또는 스페이스, ↑ 키로 상승하세요. 파이프 사이를 통과해 점수를 올려 보세요!</p>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const restartBtn = document.getElementById('restart');

        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const GRAVITY = 0.0028;
        const JUMP = -0.72;
        const GAP = 150;

        let bird;
        let pipes;
        let particles;
        let score;
        let best = Number(localStorage.getItem('flappy-best')) || 0;
        let running = false;
        let lastTime = 0;

        bestEl.textContent = best;

        function resetGame() {
            bird = {
                x: WIDTH * 0.25,
                y: HEIGHT / 2,
                radius: 18,
                velocity: 0,
                rotation: 0
            };
            pipes = [];
            particles = [];
            score = 0;
            scoreEl.textContent = score;
            running = true;
            lastTime = performance.now();
        }

        function spawnPipe() {
            const margin = 70;
            const topHeight = margin + Math.random() * (HEIGHT - GAP - margin * 2);
            pipes.push({
                x: WIDTH + 40,
                width: 64,
                top: topHeight,
                bottom: topHeight + GAP,
                passed: false
            });
        }

        function drawBackground() {
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#fefefe';
            for (let i = 0; i < 6; i++) {
                ctx.globalAlpha = 0.25;
                const radius = 40 + i * 12;
                const cx = 60 + i * 50;
                ctx.beginPath();
                ctx.arc(cx, 90, radius, Math.PI * 0.5, Math.PI * 1.5);
                ctx.arc(cx + radius, 90, radius, Math.PI * 1.5, Math.PI * 0.5);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#48a868';
            ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);
            ctx.fillStyle = '#3b8b5d';
            ctx.fillRect(0, HEIGHT - 70, WIDTH, 70);
        }

        function drawBird() {
            ctx.save();
            ctx.translate(bird.x, bird.y);
            ctx.rotate(bird.rotation);
            ctx.fillStyle = '#ffe066';
            ctx.beginPath();
            ctx.ellipse(0, 0, bird.radius + 4, bird.radius, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff922b';
            ctx.beginPath();
            ctx.arc(bird.radius + 6, 0, 10, -0.5, 0.5);
            ctx.fill();
            ctx.fillStyle = '#1e272e';
            ctx.beginPath();
            ctx.arc(6, -5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(7, -6, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawPipes(delta) {
            const speed = 0.22 + Math.min(score * 0.012, 0.18);
            for (const pipe of pipes) {
                pipe.x -= speed * delta;
                ctx.fillStyle = '#2d3436';
                ctx.fillRect(pipe.x - 3, 0, pipe.width + 6, pipe.top);
                ctx.fillRect(pipe.x - 3, pipe.bottom, pipe.width + 6, HEIGHT - pipe.bottom);
                ctx.fillStyle = '#55efc4';
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.top - 10);
                ctx.fillRect(pipe.x, pipe.bottom + 10, pipe.width, HEIGHT - pipe.bottom - 10);
                ctx.fillStyle = '#81ecec';
                ctx.fillRect(pipe.x - 5, pipe.top - 10, pipe.width + 10, 12);
                ctx.fillRect(pipe.x - 5, pipe.bottom - 2, pipe.width + 10, 12);
            }
            while (pipes.length && pipes[0].x + pipes[0].width < -60) {
                pipes.shift();
            }
        }

        function drawParticles(delta) {
            particles = particles.filter(p => {
                p.life -= delta;
                if (p.life <= 0) return false;
                p.x += p.vx * delta * 0.06;
                p.y += p.vy * delta * 0.06;
                p.vy += GRAVITY * 0.2;
                ctx.fillStyle = `rgba(255, 255, 255, ${p.life / 600})`;
                ctx.fillRect(p.x, p.y, 3, 3);
                return true;
            });
        }

        let spawnTimer = 0;

        function update(time = 0) {
            if (!running) return;
            const delta = time - lastTime;
            lastTime = time;
            spawnTimer += delta;

            drawBackground();
            drawPipes(delta);
            drawParticles(delta);

            if (spawnTimer > 1600) {
                spawnPipe();
                spawnTimer = 0;
            }

            bird.velocity += GRAVITY * delta;
            bird.y += bird.velocity * delta;
            bird.rotation = Math.min(1.2, Math.max(-0.45, bird.velocity / 8));

            if (bird.y + bird.radius > HEIGHT - 70) {
                bird.y = HEIGHT - 70 - bird.radius;
                endGame();
            }
            if (bird.y - bird.radius < 0) {
                bird.y = bird.radius;
                bird.velocity = 0;
            }

            for (const pipe of pipes) {
                if (!pipe.passed && bird.x > pipe.x + pipe.width) {
                    pipe.passed = true;
                    score++;
                    scoreEl.textContent = score;
                    if (score > best) {
                        best = score;
                        localStorage.setItem('flappy-best', best);
                        bestEl.textContent = best;
                    }
                }
                if (bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + pipe.width) {
                    if (bird.y - bird.radius < pipe.top || bird.y + bird.radius > pipe.bottom) {
                        endGame();
                    }
                }
            }

            drawBird();
            requestAnimationFrame(update);
        }

        function flap() {
            if (!running) {
                resetGame();
                spawnTimer = 0;
                spawnPipe();
                requestAnimationFrame(update);
            }
            bird.velocity = JUMP;
            bird.rotation = -0.6;
            for (let i = 0; i < 6; i++) {
                particles.push({
                    x: bird.x - 10,
                    y: bird.y + 6,
                    vx: -Math.random() * 0.12,
                    vy: (Math.random() - 0.5) * 0.4,
                    life: 600
                });
            }
        }

        function endGame() {
            if (!running) return;
            running = false;
            ctx.fillStyle = 'rgba(2, 6, 14, 0.75)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#f5f6fa';
            ctx.font = '28px Pretendard, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('게임 오버!', WIDTH / 2, HEIGHT / 2 - 16);
            ctx.font = '18px Pretendard, sans-serif';
            ctx.fillText('다시 시작 버튼이나 화면을 눌러 재도전하세요.', WIDTH / 2, HEIGHT / 2 + 22);
        }

        function handleInput(e) {
            e.preventDefault();
            flap();
        }

        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput, { passive: false });
        document.addEventListener('keydown', e => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                handleInput(e);
            }
        });

        restartBtn.addEventListener('click', () => {
            resetGame();
            spawnTimer = 0;
            pipes = [];
            spawnPipe();
            requestAnimationFrame(update);
        });

        resetGame();
        running = false;
        drawBackground();
        drawBird();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
        ctx.fillRect(40, 220, WIDTH - 80, 120);
        ctx.fillStyle = '#f5f6fa';
        ctx.font = '20px Pretendard, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('화면을 클릭하거나 스페이스 키로 시작하세요!', WIDTH / 2, 280);
    </script>
    <script src="../global-enhancements.js" defer></script>
<!-- Creator credit -->
<div class="credit-banner" aria-hidden="true">Creator: 박은성</div>

<!-- On-screen Controls -->
<div class="osc-wrap" id="osc-wrap" role="group" aria-label="On-screen game controls">
  <div class="osc">
    <div class="dpad">
      <button type="button" data-key="ArrowUp" aria-label="Up" style="grid-area:up">▲</button>
      <button type="button" data-key="ArrowLeft" aria-label="Left" style="grid-area:left">◀</button>
      <button type="button" data-key="ArrowRight" aria-label="Right" style="grid-area:right">▶</button>
      <button type="button" data-key="ArrowDown" aria-label="Down" style="grid-area:down">▼</button>
    </div>
    <div class="actions">
      <button type="button" data-key="Space" aria-label="Primary action">A</button>
      <button type="button" data-key="Enter" aria-label="Secondary action">B</button>
      <button type="button" class="pause" data-key="Escape" aria-label="Pause or resume">⏯︎</button>
    </div>
  </div>
</div>

<script>
(function(){
  const wrap = document.getElementById('osc-wrap');
  const activeTouches = new Map();

  if (wrap) {
    requestAnimationFrame(() => wrap.classList.add('is-active'));
  }

  function send(key, type){
    const ev = new KeyboardEvent(type, { key, code:key, bubbles:true, cancelable:true });
    const activeEl = document.activeElement && document.activeElement !== document.body
      ? document.activeElement : document;
    activeEl.dispatchEvent(ev);
    window.dispatchEvent(ev);
  }
  function pressStart(key){ send(key,'keydown'); }
  function pressEnd(key){ send(key,'keyup'); }

  if (wrap) {
    if ('PointerEvent' in window) {
      wrap.addEventListener('pointerdown', (e) => {
        const btn = e.target.closest('button[data-key]');
        if (!btn) return;
        e.preventDefault();
        const key = btn.dataset.key;
        btn.classList.add('is-pressed');
        pressStart(key);
        btn.setPointerCapture?.(e.pointerId);
        const finish = () => {
          pressEnd(key);
          btn.classList.remove('is-pressed');
        };
        btn.addEventListener('pointerup', finish, { once: true });
        btn.addEventListener('pointercancel', finish, { once: true });
        btn.addEventListener('lostpointercapture', finish, { once: true });
      });
    } else {
      const endTouch = (touch) => {
        const entry = activeTouches.get(touch.identifier);
        if (!entry) return;
        activeTouches.delete(touch.identifier);
        entry.btn?.classList.remove('is-pressed');
        pressEnd(entry.key);
      };
      wrap.addEventListener('touchstart', (e) => {
        for (const touch of Array.from(e.changedTouches)) {
          const el = document.elementFromPoint(touch.clientX, touch.clientY);
          const btn = el && el.closest('button[data-key]');
          if (!btn) continue;
          e.preventDefault();
          const key = btn.dataset.key;
          activeTouches.set(touch.identifier, { key, btn });
          btn.classList.add('is-pressed');
          pressStart(key);
        }
      }, { passive: false });
      wrap.addEventListener('touchend', (e) => {
        for (const touch of Array.from(e.changedTouches)) endTouch(touch);
      });
      wrap.addEventListener('touchcancel', (e) => {
        for (const touch of Array.from(e.changedTouches)) endTouch(touch);
      });
    }

    wrap.addEventListener('contextmenu', (e) => {
      if (e.target.closest('button[data-key]')) e.preventDefault();
    });
  }

  let sx=0, sy=0, tracking=false;
  const TH=24; // 스와이프 임계값(px)
  document.addEventListener('touchstart', (e)=>{
    if(e.target.closest('#osc-wrap')) return;
    tracking=true; const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY;
  }, {passive:true});
  document.addEventListener('touchend', (e)=>{
    if(!tracking) return; tracking=false;
    const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
    if(Math.abs(dx)<TH && Math.abs(dy)<TH) return;
    const key = Math.abs(dx)>Math.abs(dy) ? (dx>0?'ArrowRight':'ArrowLeft')
                                          : (dy>0?'ArrowDown':'ArrowUp');
    pressStart(key); setTimeout(()=>pressEnd(key), 50);
  }, {passive:true});
})();
</script>
</body>
</html>
