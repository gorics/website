<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <title>2048 퍼즐</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(16px, 5vw, 60px);
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            font-family: 'Pretendard', 'Noto Sans KR', system-ui, sans-serif;
        }
        .container {
            background: rgba(12, 32, 66, 0.85);
            padding: clamp(22px, 5vw, 36px);
            border-radius: clamp(20px, 4vw, 28px);
            width: min(100%, 500px);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 12px;
            flex-wrap: wrap;
        }
        h1 {
            margin: 0;
            font-size: clamp(26px, 5vw, 32px);
            letter-spacing: 1px;
        }
        .signature {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 999px;
            background: rgba(116, 192, 252, 0.2);
            color: #9ec5fe;
            font-weight: 700;
            font-size: 12px;
        }
        .score-board {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        .badge {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px 16px;
            text-align: center;
            font-weight: 600;
            line-height: 1.4;
        }
        .board {
            position: relative;
            background: rgba(6, 16, 36, 0.8);
            border-radius: 16px;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        .cell {
            padding-top: 100%;
            border-radius: 12px;
            background: rgba(255,255,255,0.06);
            position: relative;
            overflow: hidden;
        }
        .tile {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            font-weight: 700;
            font-size: 28px;
            border-radius: 12px;
            transform: scale(0.9);
            transition: transform 0.1s ease;
        }
        .tile.new {
            animation: pop 0.2s ease-out;
        }
        .tile.merged {
            animation: merge 0.25s ease-out;
        }
        @keyframes pop {
            from { transform: scale(0.2); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes merge {
            from { transform: scale(1.2); }
            to { transform: scale(1); }
        }
        button {
            margin-top: 20px;
            width: 100%;
            padding: 12px;
            background: #fbc531;
            border: none;
            border-radius: 999px;
            font-weight: 700;
            cursor: pointer;
            color: #273c75;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        button:hover, button:focus-visible {
            transform: translateY(-2px);
            box-shadow: 0 15px 25px rgba(251, 197, 49, 0.35);
            outline: none;
        }
        p {
            margin-top: 16px;
            font-size: 14px;
            color: rgba(255,255,255,0.75);
            line-height: 1.5;
            text-align: center;
        }
    </style>
    <style>
      :root { --osc-gap: 10px; --osc-btn: 56px; --osc-z: 9999; }
      .credit-banner{
        position:fixed; top:env(safe-area-inset-top,0); left:env(safe-area-inset-left,0);
        margin:8px; padding:6px 10px; font:600 14px/1.2 system-ui, sans-serif;
        background:rgba(0,0,0,.55); color:#fff; border-radius:8px; z-index:var(--osc-z);
        -webkit-backdrop-filter:saturate(150%) blur(6px); backdrop-filter:saturate(150%) blur(6px);
        user-select:none; pointer-events:none;
      }
      .osc-wrap{
        position:fixed; inset:auto 0 env(safe-area-inset-bottom,0) 0;
        display:flex; justify-content:center; gap:24px; padding:var(--osc-gap);
        z-index:var(--osc-z); touch-action:manipulation;
      }
      .osc { display:flex; align-items:center; gap:16px; }
      .osc .dpad{ display:grid; grid-template-areas:
          ".    up    ."
          "left  mid  right"
          ".   down   .";
        gap:8px; align-items:center; justify-items:center;
      }
      .osc .actions{ display:flex; gap:10px; }
      .osc button{
        min-width:var(--osc-btn); min-height:var(--osc-btn);
        border:0; border-radius:12px; font:700 16px system-ui, sans-serif;
        background:rgba(255,255,255,.9); color:#111; box-shadow:0 2px 10px rgba(0,0,0,.2);
      }
      .osc .pause{ min-width:72px; }
      /* 게임 화면 가려짐 방지 */
      body{ padding-bottom: calc(env(safe-area-inset-bottom,0) + 110px); }
      @media (pointer:fine){ /* 데스크톱이면 패드 숨김 */
        .osc-wrap{ display:none; } body{ padding-bottom:0; }
      }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div style="display:flex;flex-direction:column;gap:6px;">
                <div class="signature">박은성이 만든 게임</div>
                <h1>2048</h1>
            </div>
            <div class="score-board">
                <div class="badge">점수<br><span id="score">0</span></div>
                <div class="badge">최고 기록<br><span id="best">0</span></div>
            </div>
        </header>
        <div class="board" id="board"></div>
        <button id="restart">새 게임</button>
        <p>방향키 또는 스와이프(모바일)로 타일을 이동하세요. 같은 숫자가 만나면 합쳐집니다!</p>
    </div>

    <script>
        const boardEl = document.getElementById('board');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const restartBtn = document.getElementById('restart');
        const size = 4;
        let board, score, bestScore = Number(localStorage.getItem('best-2048')) || 0;
        bestEl.textContent = bestScore;

        function createBoard() {
            board = Array.from({ length: size }, () => Array(size).fill(0));
            score = 0;
            updateScore();
            boardEl.innerHTML = '';
            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                boardEl.appendChild(cell);
            }
            addRandomTile();
            addRandomTile();
            render();
        }

        function updateScore() {
            scoreEl.textContent = score;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('best-2048', bestScore);
                bestEl.textContent = bestScore;
            }
        }

        function addRandomTile() {
            const empty = [];
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (board[y][x] === 0) empty.push({ x, y });
                }
            }
            if (!empty.length) return false;
            const { x, y } = empty[Math.floor(Math.random() * empty.length)];
            board[y][x] = Math.random() < 0.9 ? 2 : 4;
            return true;
        }

        function render() {
            boardEl.querySelectorAll('.cell').forEach((cell, index) => {
                cell.innerHTML = '';
                const x = index % size;
                const y = Math.floor(index / size);
                const value = board[y][x];
                if (value) {
                    const tile = document.createElement('div');
                    tile.className = 'tile new tile-' + value;
                    tile.style.background = getTileColor(value);
                    tile.style.color = value <= 4 ? '#2f3640' : '#f5f6fa';
                    tile.textContent = value;
                    cell.appendChild(tile);
                    requestAnimationFrame(() => tile.classList.remove('new'));
                }
            });
        }

        function getTileColor(value) {
            const palette = {
                2: '#cfe2ff',
                4: '#9ec5fe',
                8: '#74c0fc',
                16: '#4dabf7',
                32: '#339af0',
                64: '#1864ab',
                128: '#ffd43b',
                256: '#fab005',
                512: '#f08c00',
                1024: '#e8590c',
                2048: '#d9480f'
            };
            return palette[value] || '#ad1457';
        }

        function slide(row) {
            const filtered = row.filter(v => v !== 0);
            const merged = [];
            let skip = false;
            for (let i = 0; i < filtered.length; i++) {
                if (skip) {
                    skip = false;
                    continue;
                }
                if (filtered[i] === filtered[i + 1]) {
                    const value = filtered[i] * 2;
                    score += value;
                    merged.push(value);
                    skip = true;
                } else {
                    merged.push(filtered[i]);
                }
            }
            while (merged.length < size) merged.push(0);
            return merged;
        }

        function rowsEqual(a, b) {
            return a.length === b.length && a.every((v, i) => v === b[i]);
        }

        function move(direction) {
            const snapshot = board.map(row => [...row]);
            if (direction === 'left') {
                for (let y = 0; y < size; y++) {
                    board[y] = slide(board[y]);
                }
            } else if (direction === 'right') {
                for (let y = 0; y < size; y++) {
                    board[y] = slide(board[y].slice().reverse()).reverse();
                }
            } else if (direction === 'up') {
                for (let x = 0; x < size; x++) {
                    const column = board.map(row => row[x]);
                    const newColumn = slide(column);
                    board.forEach((row, y) => row[x] = newColumn[y]);
                }
            } else if (direction === 'down') {
                for (let x = 0; x < size; x++) {
                    const column = board.map(row => row[x]).reverse();
                    const newColumn = slide(column).reverse();
                    board.forEach((row, y) => row[x] = newColumn[y]);
                }
            }
            return !snapshot.every((row, y) => row.every((value, x) => value === board[y][x]));
        }

        function canMove() {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const value = board[y][x];
                    if (value === 0) return true;
                    if (x < size - 1 && board[y][x + 1] === value) return true;
                    if (y < size - 1 && board[y + 1][x] === value) return true;
                }
            }
            return false;
        }

        function handleMove(direction) {
            const moved = move(direction);
            if (!moved) return;
            updateScore();
            addRandomTile();
            render();
            if (!canMove()) {
                setTimeout(() => alert('게임 오버! 점수: ' + score), 200);
            }
        }

        document.addEventListener('keydown', (e) => {
            const keyMap = {
                ArrowLeft: 'left',
                ArrowRight: 'right',
                ArrowUp: 'up',
                ArrowDown: 'down'
            };
            if (keyMap[e.key]) {
                e.preventDefault();
                handleMove(keyMap[e.key]);
            }
        });

        let startX, startY;
        boardEl.addEventListener('touchstart', e => {
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
        });
        boardEl.addEventListener('touchend', e => {
            const touch = e.changedTouches[0];
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) handleMove(dx > 0 ? 'right' : 'left');
            } else {
                if (Math.abs(dy) > 30) handleMove(dy > 0 ? 'down' : 'up');
            }
        });

        restartBtn.addEventListener('click', createBoard);

        createBoard();
    </script>
    <script src="../global-enhancements.js" defer></script>
<!-- Creator credit -->
<div class="credit-banner" aria-hidden="true">Creator: 박은성</div>

<!-- On-screen Controls -->
<div class="osc-wrap" id="osc-wrap" role="group" aria-label="On-screen game controls">
  <div class="osc">
    <div class="dpad">
      <button data-key="ArrowUp"    style="grid-area:up">▲</button>
      <button data-key="ArrowLeft"  style="grid-area:left">◀</button>
      <button data-key="ArrowRight" style="grid-area:right">▶</button>
      <button data-key="ArrowDown"  style="grid-area:down">▼</button>
    </div>
    <div class="actions">
      <button data-key="Space">A</button>
      <button data-key="Enter">B</button>
      <button class="pause" data-key="Escape">⏯︎</button>
    </div>
  </div>
</div>

<script>
(function(){
  // 일부 게임이 window/document/canvas 등 서로 다른 타깃을 구독하므로, 광범위 전파
  function send(key, type){
    const ev = new KeyboardEvent(type, { key, code:key, bubbles:true, cancelable:true });
    const t = document.activeElement && document.activeElement !== document.body
      ? document.activeElement : document;
    t.dispatchEvent(ev); window.dispatchEvent(ev);
  }
  function pressStart(key){ send(key,'keydown'); }
  function pressEnd(key){ send(key,'keyup'); }

  // 버튼 터치/클릭 → 키 이벤트 변환
  document.getElementById('osc-wrap')?.addEventListener('pointerdown', e=>{
    const btn = e.target.closest('button[data-key]'); if(!btn) return;
    e.preventDefault(); btn.setPointerCapture?.(e.pointerId);
    pressStart(btn.dataset.key);
    btn.addEventListener('pointerup',  ()=>pressEnd(btn.dataset.key), { once:true });
    btn.addEventListener('pointercancel',()=>pressEnd(btn.dataset.key), { once:true });
    btn.addEventListener('lostpointercapture',()=>pressEnd(btn.dataset.key), { once:true });
  });

  // 스와이프 제스처 → 방향키
  let sx=0, sy=0, tracking=false;
  const TH=24; // 스와이프 임계값(px)
  document.addEventListener('touchstart', (e)=>{
    // 오버레이 위 스와이프는 무시
    if(e.target.closest('#osc-wrap')) return;
    tracking=true; const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY;
  }, {passive:true});
  document.addEventListener('touchend', (e)=>{
    if(!tracking) return; tracking=false;
    const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
    if(Math.abs(dx)<TH && Math.abs(dy)<TH) return;
    const key = Math.abs(dx)>Math.abs(dy) ? (dx>0?'ArrowRight':'ArrowLeft')
                                          : (dy>0?'ArrowDown':'ArrowUp');
    pressStart(key); setTimeout(()=>pressEnd(key), 50);
  }, {passive:true});
})();
</script>
</body>
</html>
