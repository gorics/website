<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Nebulous-like Web Game — Single File (v1.2)</title>
  <style>
    :root{
      --bg:#0b1020; --ink:#e6ebff; --accent:#7aa2ff; --panel:rgba(8,12,24,.62); --bd:rgba(255,255,255,.09);
    }
    html,body{margin:0;height:100%;overflow:hidden;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Helvetica,Arial,sans-serif}
    #game{position:fixed;inset:0;display:block;background:radial-gradient(1200px 800px at 50% 40%, #0e1530 0%, #0b1020 70%)}
    .hud{position:fixed;z-index:5;pointer-events:none}
    .panel{background:var(--panel);backdrop-filter: blur(8px);border:1px solid var(--bd);border-radius:14px;padding:10px}
    .top-left{top:10px;left:10px}
    .top-right{top:10px;right:10px}
    .bottom-center{left:50%;transform:translateX(-50%);bottom:10px}
    .btns{pointer-events:auto;display:flex;gap:8px}
    .btn{cursor:pointer;background:rgba(16,24,48,.7);border:1px solid rgba(255,255,255,.12);padding:10px 14px;border-radius:14px;font-weight:700}
    .btn:active{transform:translateY(1px)}
    #mini{position:fixed;right:10px;bottom:10px;width:190px;height:124px;border-radius:12px;background:rgba(8,12,24,.55);border:1px solid var(--bd);z-index:5}
    #mini canvas{width:100%;height:100%}
    #settings{position:fixed;left:10px;bottom:10px;z-index:6;pointer-events:auto}
    .row{display:flex;align-items:center;gap:8px;margin-top:6px}
    .link{pointer-events:auto;color:#9fc0ff}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud top-left panel">
    <div style="font-weight:800">Nebula Blobs <span style="opacity:.7">v1.2</span></div>
    <div>Mass <b id="mass">0</b> · Pieces <b id="pieces">1</b> · Rank <b id="rank">1</b></div>
    <div>Speed <b id="spd">0</b> · Merge <b id="merge">—</b></div>
    <div>Controls: Mouse/Touch move · <b>Space</b> Split · <b>E</b> Eject · <b>P</b> Pause · <b>R</b> Reset</div>
    <div id="msg" style="opacity:.8"></div>
  </div>

  <div class="hud top-right panel">
    <div style="font-weight:700;margin-bottom:6px">Leaderboard</div>
    <ol id="lb" style="margin:0;padding-left:18px"></ol>
  </div>

  <div class="hud bottom-center btns">
    <div class="btn" id="btnSplit">Split</div>
    <div class="btn" id="btnEject">Eject</div>
    <div class="btn" id="btnPause">Pause</div>
  </div>

  <div id="mini"><canvas id="miniCanvas"></canvas></div>

  <div id="settings" class="panel">
    <div style="font-weight:700">Settings</div>
    <div class="row"><label> Bots: <input id="optBots" type="number" min="0" max="32" step="1" value="8" style="width:56px"></label></div>
    <div class="row"><label> Foods: <input id="optFoods" type="number" min="200" max="2000" step="50" value="900" style="width:70px"></label></div>
    <div class="row"><button class="btn" id="btnApply">Apply</button><button class="btn" id="btnNewMatch">New Match</button></div>
    <div class="row" style="opacity:.8">Made for education/prototype. Single-file canvas.</div>
  </div>

<script>
(()=>{
'use strict';
// ============================ CONFIG ============================
const WORLD_SIZE = 7000;       // world bounds [-S..+S]
let   FOOD_TARGET = 900;       // maintained count
let   BOT_TARGET  = 8;         // bots count (can change in settings)
const HOLE_COUNT  = 7;         // black holes
const START_MASS  = 120;
const FOOD_MASS   = 2.0;
const EJECT_MASS  = 16;
const BASE_SPEED  = 1.9;       // base move factor
const SPLIT_VEL   = 12;        // split impulse
const PELLET_DRAG = 0.985;
const BLOB_DRAG   = 0.94;
const MAX_PIECES  = 16;
const MERGE_BASE  = 10000;     // ms base; scales with piece size
const ABSORB_RATIO= 1.18;      // mass ratio to allow certain absorb
const ABSORB_OVERLAP = 0.38;   // overlap factor threshold
const DT_CAP      = 28;        // ms cap per frame
const GRID_SIZE   = 420;       // spatial hash cell size

// ========================== SHORTCUTS ===========================
const $ = (id)=>document.getElementById(id);
const canvas = $("game"); const ctx = canvas.getContext('2d');
const miniEl = $("miniCanvas"); const mctx = miniEl.getContext('2d');
const massEl=$("mass"), piecesEl=$("pieces"), spdEl=$("spd"), rankEl=$("rank"), mergeEl=$("merge"), lbEl=$("lb"), msgEl=$("msg");
const optBots=$("optBots"), optFoods=$("optFoods");

let W=innerWidth, H=innerHeight; canvas.width=W; canvas.height=H; miniEl.width=190; miniEl.height=124;
addEventListener('resize',()=>{W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H;});

// =========================== UTILS ==============================
const TAU=Math.PI*2; const clamp=(v,a,b)=>v<a?a:v>b?b:v; const rand=(a=0,b=1)=>a+Math.random()*(b-a); const rint=(a,b)=>Math.floor(rand(a,b));
const len=(x,y)=>Math.hypot(x,y); const lerp=(a,b,t)=>a+(b-a)*t;
const massToR=(m)=>Math.sqrt(m/Math.PI);

// ========================== ENTITIES ============================
class Blob{ constructor({id,x,y,mass,color,name,isPlayer=false}){ Object.assign(this,{id,x,y,mass,color,name,isPlayer}); this.vx=0; this.vy=0; this.mergeAt=0; }
  get r(){return massToR(this.mass)}
  get speed(){ return BASE_SPEED / Math.sqrt(Math.max(this.mass,60)/60); }
  update(dt, steer){
    // steer = {x,y} desired world point
    if(steer){ const dx=steer.x-this.x, dy=steer.y-this.y; const L=len(dx,dy)||1; const ax=(dx/L)*this.speed, ay=(dy/L)*this.speed; this.vx=(this.vx+ax)*BLOB_DRAG; this.vy=(this.vy+ay)*BLOB_DRAG; }
    else { this.vx*=BLOB_DRAG; this.vy*=BLOB_DRAG; }
    this.x += this.vx*dt*0.06; this.y += this.vy*dt*0.06;
    const r=this.r; this.x=clamp(this.x,-WORLD_SIZE+r,WORLD_SIZE-r); this.y=clamp(this.y,-WORLD_SIZE+r,WORLD_SIZE-r);
  }
}
class Food{ constructor(x,y){ this.x=x; this.y=y; this.mass=FOOD_MASS; this.color=`hsl(${rint(180,300)} 80% 65%)`; } get r(){return 3.1} }
class Pellet{ constructor(x,y,vx,vy){Object.assign(this,{x,y,vx,vy}); this.mass=EJECT_MASS; this.life=12000;} get r(){return 3.2} }
class Hole{ constructor(x,y,r){Object.assign(this,{x,y,r}); this.vx=0; this.vy=0;} update(dt){ this.x+=this.vx*dt*0.06; this.y+=this.vy*dt*0.06; this.vx*=0.985; this.vy*=0.985; this.x=clamp(this.x,-WORLD_SIZE+this.r,WORLD_SIZE-this.r); this.y=clamp(this.y,-WORLD_SIZE+this.r,WORLD_SIZE-this.r);} }

// ========================= WORLD STATE ==========================
const foods=[], pellets=[], holes=[], blobs=[]; // blobs contains all pieces (player/bots)
let playerId=1; let running=true; let gameOver=false; let tPrev=performance.now(); let smoothedFps=60;
let camera={x:0,y:0,scale:1}; let pointer={active:false,x:0,y:0};

// spatial hash
const grid=new Map(); const cellKey=(x,y)=> (Math.floor(x/GRID_SIZE)+','+Math.floor(y/GRID_SIZE));
function gridRebuild(){ grid.clear(); const push=(k,v)=>{const a=grid.get(k); if(a) a.push(v); else grid.set(k,[v]);};
  for(const arr of [foods,pellets,holes,blobs]) for(const o of arr){ push(cellKey(o.x,o.y), o); }
}
function nearby(x,y){ const cx=Math.floor(x/GRID_SIZE), cy=Math.floor(y/GRID_SIZE); const out=[]; for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++){ const a=grid.get((cx+i)+','+(cy+j)); if(a) out.push(...a); } return out; }

function reset(){
  foods.length=0; pellets.length=0; holes.length=0; blobs.length=0; gameOver=false; msg('');
  for(let i=0;i<HOLE_COUNT;i++) holes.push(new Hole(rand(-WORLD_SIZE*0.8,WORLD_SIZE*0.8), rand(-WORLD_SIZE*0.8,WORLD_SIZE*0.8), rand(42,68)));
  for(let i=0;i<FOOD_TARGET;i++) foods.push(new Food(rand(-WORLD_SIZE,WORLD_SIZE), rand(-WORLD_SIZE,WORLD_SIZE)));
  // player starts center-ish
  const px=rand(-WORLD_SIZE*0.2,WORLD_SIZE*0.2), py=rand(-WORLD_SIZE*0.2,WORLD_SIZE*0.2);
  blobs.push(new Blob({id:playerId,x:px,y:py,mass:START_MASS,color:'#9af',name:'YOU',isPlayer:true}));
  // bots
  for(let i=0;i<BOT_TARGET;i++) blobs.push(new Blob({id:100+i,x:rand(-WORLD_SIZE,WORLD_SIZE),y:rand(-WORLD_SIZE,WORLD_SIZE),mass:rand(90,220),color:`hsl(${rint(0,360)} 75% 65%)`,name:`BOT-${i+1}`}));
}
reset();

// ============================ INPUT =============================
function setPointerFrom(e){ const rect=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top; pointer.active=true; pointer.x=x; pointer.y=y; }
canvas.addEventListener('mousemove',e=>setPointerFrom(e)); canvas.addEventListener('mouseleave',()=>pointer.active=false);
canvas.addEventListener('touchstart',e=>setPointerFrom(e),{passive:true}); canvas.addEventListener('touchmove',e=>setPointerFrom(e),{passive:true}); canvas.addEventListener('touchend',()=>pointer.active=false);

addEventListener('keydown',e=>{ if(e.code==='Space'){ doSplit(); e.preventDefault(); } else if(e.key==='e'||e.key==='E'){ doEject(); } else if(e.key==='p'||e.key==='P'){ running=!running; $("btnPause").textContent= running? 'Pause':'Resume'; } else if(e.key==='r'||e.key==='R'){ reset(); } });
$("btnSplit").onclick=()=>doSplit(); $("btnEject").onclick=()=>doEject(); $("btnPause").onclick=()=>{running=!running; $("btnPause").textContent= running? 'Pause':'Resume';};
$("btnApply").onclick=()=>{ BOT_TARGET=clamp(parseInt(optBots.value||BOT_TARGET),0,32); FOOD_TARGET=clamp(parseInt(optFoods.value||FOOD_TARGET),200,2000); msg('Applied. New matches will use these.'); };
$("btnNewMatch").onclick=()=>reset();

const myPieces = ()=> blobs.filter(b=>b.id===playerId);
const myMass   = ()=> myPieces().reduce((s,b)=>s+b.mass,0);

function screenToWorld(x,y){ return { x:(x - W/2)/camera.scale + camera.x, y:(y - H/2)/camera.scale + camera.y } }

function doSplit(){ const mine=myPieces(); if(!mine.length || mine.length>=MAX_PIECES) return; const worldAim= pointer.active? screenToWorld(pointer.x,pointer.y) : {x:camera.x,y:camera.y};
  for(const b of mine){ if(b.mass<60) continue; const m=b.mass/2; b.mass-=m; const dx=worldAim.x - b.x, dy=worldAim.y - b.y; const L=len(dx,dy)||1; const vx=(dx/L)*SPLIT_VEL, vy=(dy/L)*SPLIT_VEL; const nb=new Blob({id:b.id,x:b.x+(dx/L)*(b.r+4),y:b.y+(dy/L)*(b.r+4),mass:m,color:b.color,name:b.name,isPlayer:b.isPlayer}); nb.vx=b.vx+vx; nb.vy=b.vy+vy; const now=performance.now(); nb.mergeAt= now + MERGE_BASE * (Math.sqrt(m)/8); b.mergeAt= now + MERGE_BASE * (Math.sqrt(b.mass)/8); blobs.push(nb);} }

function doEject(){ const worldAim= pointer.active? screenToWorld(pointer.x,pointer.y) : {x:camera.x,y:camera.y};
  for(const b of myPieces()){ if(b.mass<40) continue; b.mass-=EJECT_MASS; const dx=worldAim.x-b.x, dy=worldAim.y-b.y; const L=len(dx,dy)||1; const vx=(dx/L)*16, vy=(dy/L)*16; pellets.push(new Pellet(b.x+(dx/L)*(b.r+6), b.y+(dy/L)*(b.r+6), b.vx+vx, b.vy+vy)); }
}

// ============================ AI ================================
function botThink(dt){ const ids=new Set(blobs.map(b=>b.id));
  for(const id of ids){ if(id<100) continue; // bots only
    const pieces = blobs.filter(b=>b.id===id); if(!pieces.length) continue; const mass=pieces.reduce((s,b)=>s+b.mass,0);
    // centroid
    let cx=0,cy=0; for(const p of pieces){ cx+=p.x*p.mass; cy+=p.y*p.mass; } cx/=mass; cy/=mass;
    // find nearest prey and biggest threat
    let prey=null, pd=1e9, threat=null, td=1e9;
    for(const b of blobs){ if(b.id===id) continue; const d=len(b.x-cx,b.y-cy); if(b.mass < mass*0.6 && d<pd){ prey=b; pd=d; } if(b.mass > mass*1.3 && d<td){ threat=b; td=d; } }
    // target point
    let tx=cx, ty=cy;
    if(threat && td<1200){ // flee
      tx = cx + (cx-threat.x)*2; ty = cy + (cy-threat.y)*2;
    } else if(prey){ tx=prey.x; ty=prey.y; }
    for(const p of pieces){ p.update(dt, {x:tx, y:ty}); }
    // opportunistic split
    if(prey && mass>140 && Math.random()<0.002){ // small chance
      const angle=Math.atan2(prey.y-cy, prey.x-cx); const cand=pieces[0]; if(cand && pieces.length<MAX_PIECES){ const m=cand.mass/2; if(m>40){ cand.mass-=m; const nb=new Blob({id:cand.id,x:cand.x+Math.cos(angle)*(cand.r+4),y:cand.y+Math.sin(angle)*(cand.r+4),mass:m,color:cand.color,name:cand.name}); nb.vx=cand.vx+Math.cos(angle)*SPLIT_VEL; nb.vy=cand.vy+Math.sin(angle)*SPLIT_VEL; const now=performance.now(); nb.mergeAt=now+MERGE_BASE*(Math.sqrt(m)/8); cand.mergeAt=now+MERGE_BASE*(Math.sqrt(cand.mass)/8); blobs.push(nb);} }
    }
  }
}

// ========================= SIMULATION ===========================
function step(dt){
  // rebuild grid (cheap because of GRID_SIZE)
  gridRebuild();

  // update holes
  for(const h of holes) h.update(dt);

  // update pellets
  for(const p of pellets){ p.x+=p.vx*dt*0.06; p.y+=p.vy*dt*0.06; p.vx*=PELLET_DRAG; p.vy*=PELLET_DRAG; p.life-=dt; }
  for(let i=pellets.length-1;i>=0;i--) if(pellets[i].life<=0) pellets.splice(i,1);

  // pellet vs holes: nudge holes
  for(const h of holes){ for(const p of nearby(h.x,h.y)){ if(!(p instanceof Pellet)) continue; const d=len(p.x-h.x,p.y-h.y); if(d<h.r+10){ const k=0.12; const dx=h.x-p.x, dy=h.y-p.y; const L=len(dx,dy)||1; h.vx += (dx/L)*k; h.vy += (dy/L)*k; p.life=0; } } }

  // update blobs (player steer + bots handled elsewhere)
  const mine=myPieces();
  const aim = pointer.active? screenToWorld(pointer.x,pointer.y) : {x:camera.x,y:camera.y};
  for(const b of mine) b.update(dt, aim);
  botThink(dt);

  // blobs eat foods
  for(const b of blobs){ const r=b.r; for(const o of nearby(b.x,b.y)){ if(!(o instanceof Food)) continue; if(Math.abs(o.x-b.x)>r+6||Math.abs(o.y-b.y)>r+6) continue; if(len(o.x-b.x,o.y-b.y)<r){ b.mass+=o.mass; o.mass=0; } } }
  for(let i=foods.length-1;i>=0;i--) if(foods[i].mass<=0) foods.splice(i,1);
  while(foods.length<FOOD_TARGET) foods.push(new Food(rand(-WORLD_SIZE,WORLD_SIZE), rand(-WORLD_SIZE,WORLD_SIZE)));

  // pellets absorbed by blobs
  for(const b of blobs){ const r=b.r+6; for(const p of nearby(b.x,b.y)){ if(!(p instanceof Pellet)) continue; if(Math.abs(p.x-b.x)>r||Math.abs(p.y-b.y)>r) continue; if(len(p.x-b.x,p.y-b.y)<r){ b.mass+=p.mass; p.life=0; } } }
  for(let i=pellets.length-1;i>=0;i--) if(pellets[i].life<=0) pellets.splice(i,1);

  // blob vs hole interactions
  for(const b of blobs){ for(const h of nearby(b.x,b.y)){ if(!(h instanceof Hole)) continue; const d=len(b.x-h.x,b.y-h.y); if(d < h.r + b.r*0.8){ if(b.r>h.r*0.9 && blobs.length<140){ const pieces=Math.min(6, MAX_PIECES - myPieces().length + (b.isPlayer?0:2)); if(pieces>1){ const share=b.mass/pieces; const ang0=rand(0,TAU); for(let k=0;k<pieces;k++){ const a=ang0+k*(TAU/pieces); const nb=new Blob({id:b.id,x:b.x+Math.cos(a)*(b.r+8),y:b.y+Math.sin(a)*(b.r+8),mass:share,color:b.color,name:b.name,isPlayer:b.isPlayer}); nb.vx=b.vx+Math.cos(a)*10; nb.vy=b.vy+Math.sin(a)*10; nb.mergeAt=performance.now()+MERGE_BASE*(Math.sqrt(share)/6); blobs.push(nb);} b.mass=0; } } } } }
  for(let i=blobs.length-1;i>=0;i--) if(blobs[i].mass<=0) blobs.splice(i,1);

  // blob vs blob
  for(let i=0;i<blobs.length;i++){
    const A=blobs[i]; if(!A) continue;
    for(let j=i+1;j<blobs.length;j++){
      const B=blobs[j]; if(!B) continue; const dx=B.x-A.x, dy=B.y-A.y; const d=len(dx,dy); const rA=A.r, rB=B.r; if(d>rA+rB) continue;
      // same owner: merge when eligible
      if(A.id===B.id){ const now=performance.now(); if(now> A.mergeAt && now> B.mergeAt){ if(A.mass>=B.mass){ A.mass+=B.mass; blobs.splice(j,1); j--; } else { B.mass+=A.mass; blobs.splice(i,1); i--; break; } } continue; }
      // different owners: absorption if ratio & overlap satisfied
      const bigger = A.mass>B.mass?A:B; const smaller= bigger===A?B:A; const ratio=bigger.mass/(smaller.mass+1e-6);
      if(ratio>ABSORB_RATIO && d < bigger.r - smaller.r*ABSORB_OVERLAP){ bigger.mass += smaller.mass; smaller.mass=0; }
    }
  }
  for(let i=blobs.length-1;i>=0;i--) if(blobs[i].mass<=0) blobs.splice(i,1);

  // camera follow & zoom
  if(mine.length){ let cx=0,cy=0,m=0; for(const b of mine){ cx+=b.x*b.mass; cy+=b.y*b.mass; m+=b.mass; } cx/=m; cy/=m; camera.x=lerp(camera.x,cx,0.12); camera.y=lerp(camera.y,cy,0.12); const targetScale=clamp( 1.8 / Math.sqrt(m/150), 0.28, 1.9 ); camera.scale=lerp(camera.scale,targetScale,0.08); }

  // HUD
  const mm=myMass(); massEl.textContent=mm.toFixed(0); piecesEl.textContent=myPieces().length; const sp=myPieces().length? myPieces().reduce((s,b)=>s+b.speed,0)/myPieces().length : 0; spdEl.textContent=sp.toFixed(2); const mergeRemain=myPieces().reduce((mx,b)=>Math.max(0,(b.mergeAt||0)-performance.now()),0); mergeEl.textContent = mergeRemain? (mergeRemain/1000).toFixed(1)+'s':'—';
  // rank
  const totals=new Map(); for(const b of blobs){ totals.set(b.id,(totals.get(b.id)||0)+b.mass); }
  const rows=[...totals.entries()].map(([id,mass])=>({id,mass,name:id===playerId?'YOU':('BOT-'+(id-99))})).sort((a,b)=>b.mass-a.mass);
  rankEl.textContent = rows.findIndex(r=>r.id===playerId)+1; lbEl.innerHTML = rows.slice(0,8).map(r=>`<li>${r.name} — ${r.mass.toFixed(0)}</li>`).join('');

  // game over & respawn
  if(!myPieces().length && !gameOver){ gameOver=true; msg('You were eaten. Respawning in 3s…'); setTimeout(()=>{ if(!myPieces().length){ const px=rand(-WORLD_SIZE*0.2,WORLD_SIZE*0.2), py=rand(-WORLD_SIZE*0.2,WORLD_SIZE*0.2); blobs.push(new Blob({id:playerId,x:px,y:py,mass:START_MASS,color:'#9af',name:'YOU',isPlayer:true})); msg(''); } gameOver=false; },3000); }
}

function msg(s){ msgEl.textContent=s; }

// =========================== RENDER =============================
function draw(){ ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H); ctx.translate(W/2,H/2); ctx.scale(camera.scale,camera.scale); ctx.translate(-camera.x,-camera.y);
  // grid
  ctx.lineWidth=1/camera.scale; ctx.strokeStyle='rgba(255,255,255,.06)'; const g=140; const startX=Math.floor((-W/2/camera.scale+camera.x)/g)*g - g*4; const endX=Math.floor((W/2/camera.scale+camera.x)/g)*g + g*4; const startY=Math.floor((-H/2/camera.scale+camera.y)/g)*g - g*4; const endY=Math.floor((H/2/camera.scale+camera.y)/g)*g + g*4; ctx.beginPath(); for(let x=startX;x<=endX;x+=g){ ctx.moveTo(x,startY); ctx.lineTo(x,endY);} for(let y=startY;y<=endY;y+=g){ ctx.moveTo(startX,y); ctx.lineTo(endX,y);} ctx.stroke();
  // world border
  ctx.strokeStyle='rgba(122,162,255,.35)'; ctx.lineWidth=2/camera.scale; ctx.strokeRect(-WORLD_SIZE,-WORLD_SIZE,WORLD_SIZE*2,WORLD_SIZE*2);
  // foods
  for(const f of foods){ ctx.beginPath(); ctx.fillStyle=f.color; ctx.arc(f.x,f.y,f.r,0,TAU); ctx.fill(); }
  // holes
  for(const h of holes){ const grd=ctx.createRadialGradient(h.x-h.r*0.3,h.y-h.r*0.3,h.r*0.2,h.x,h.y,h.r); grd.addColorStop(0,'rgba(20,30,60,.9)'); grd.addColorStop(1,'rgba(5,8,18,.6)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,TAU); ctx.fill(); ctx.strokeStyle='rgba(122,162,255,.5)'; ctx.lineWidth=2/camera.scale; ctx.stroke(); }
  // pellets
  ctx.fillStyle='rgba(255,255,255,.9)'; for(const p of pellets){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,TAU); ctx.fill(); }
  // blobs
  for(const b of blobs){ const grd=ctx.createRadialGradient(b.x-b.r*0.4,b.y-b.r*0.4,b.r*0.4,b.x,b.y,b.r); grd.addColorStop(0,b.color); grd.addColorStop(1,'rgba(255,255,255,.08)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=3/camera.scale; ctx.stroke(); if(b.r>20){ ctx.fillStyle='rgba(255,255,255,.9)'; ctx.font=`${Math.max(12,b.r*0.35)}px/1 sans-serif`; ctx.textAlign='center'; ctx.fillText(b.name||'', b.x, b.y+4);} if(b.r>26){ ctx.fillStyle='rgba(255,255,255,.7)'; ctx.font=`${Math.max(11,b.r*0.28)}px/1 sans-serif`; ctx.fillText(b.mass.toFixed(0), b.x, b.y+b.r*0.55);} }

  // minimap
  mctx.clearRect(0,0,miniEl.width,miniEl.height); mctx.fillStyle='rgba(255,255,255,.05)'; mctx.fillRect(0,0,miniEl.width,miniEl.height); mctx.strokeStyle='rgba(122,162,255,.5)'; mctx.strokeRect(0.5,0.5,miniEl.width-1,miniEl.height-1);
  const wx=(x)=> (x+WORLD_SIZE)/(WORLD_SIZE*2) * miniEl.width; const wy=(y)=> (y+WORLD_SIZE)/(WORLD_SIZE*2) * miniEl.height;
  for(const b of blobs){ mctx.fillStyle = (b.id===playerId)? 'rgba(122,162,255,.95)' : 'rgba(255,255,255,.6)'; mctx.beginPath(); mctx.arc(wx(b.x), wy(b.y), Math.max(2, Math.log2(b.mass+2)), 0, TAU); mctx.fill(); }
}

// ============================ LOOP ==============================
function loop(now){ const dt=Math.min(now - tPrev, DT_CAP); tPrev=now; const alpha=0.05; smoothedFps = lerp(smoothedFps, 1000/dt, alpha); if(running){ step(dt); draw(); } requestAnimationFrame(loop); }
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
