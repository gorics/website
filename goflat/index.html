<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>vFlat Lite — 자동 보정 (안전모드)</title>
  <meta name="description" content="이미지/PDF 자동 원근/기울기/조명/대비 보정. HEIC 지원. 안전한 이진화."/>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><rect width='128' height='128' rx='24' fill='%2360a5fa'/><path d='M30 84c16-32 52-32 68 0' stroke='%230b0c10' stroke-width='10' fill='none' stroke-linecap='round'/><circle cx='44' cy='48' r='6' fill='%230b0c10'/><circle cx='84' cy='48' r='6' fill='%230b0c10'/></svg>" type="image/svg+xml">

  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.worker.min.js";</script>
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
    :root{ --bg:#0b0c10; --fg:#e5e7eb; --muted:#94a3b8; --card:#111827; --accent:#60a5fa; --danger:#ef4444; --border:#1f2937; }
    *{box-sizing:border-box} html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
    .container{max-width:1100px;margin:0 auto;padding:16px}
    header h1{margin:0 0 4px 0}.subtitle{color:var(--muted);margin:0 0 12px 0}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:16px}
    .dropzone{border:2px dashed var(--border);border-radius:12px;padding:24px;text-align:center;color:var(--muted);cursor:pointer;position:relative}
    .dropzone.drag{border-color:var(--accent);color:var(--fg)}
    .dropzone input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer}
    .controls .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin:8px 0}
    .controls label{display:flex;flex-direction:column;font-size:14px;color:var(--muted)}
    .controls .btn{padding:10px 14px;border:1px solid var(--border);border-radius:10px;background:#0f172a;color:var(--fg);cursor:pointer}
    .controls .btn.primary{background:var(--accent);border-color:transparent;color:#0b0c10;font-weight:600}
    .controls .btn.danger{background:var(--danger);border-color:transparent;color:white}
    .controls .status{margin-top:8px;color:var(--muted);font-size:13px}
    .queue{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .item{background:#0f172a;border:1px solid var(--border);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px}
    .item .thumb{width:100%;aspect-ratio:3/4;background:#111;border-radius:8px;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .item img{max-width:100%}
    .item .meta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;gap:6px}
    .item .actions{display:flex;gap:8px}
    .item .actions .btn{flex:1;text-align:center;padding:8px;border:1px solid var(--border);background:#0b1220;color:var(--fg);border-radius:8px}
    .footer{color:var(--muted);font-size:12px;text-align:center;margin-bottom:24px}
    progress{width:100%; height:10px; border-radius:6px; background:#0b1220}
  </style>
</head>
<body>
  <header class="container">
    <h1>vFlat Lite</h1>
    <p class="subtitle">GitHub Pages용 • 업로드하면 자동 보정 시작(안전모드)</p>
  </header>

  <main class="container">
    <section class="card">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="업로드 영역">
        <div><strong>이미지(JPG/PNG/HEIC) 또는 PDF</strong>를 끌어놓거나 눌러서 업로드하세요.</div>
        <input id="fileInput"
               type="file"
               accept="image/*,application/pdf,.pdf,.heic,.heif,.jpg,.jpeg,.png"
               multiple />
      </div>

      <div class="controls">
        <div class="row">
          <label><span>자동 흑백(Adaptive)</span><input id="useBW" type="checkbox" checked /></label>
          <label><span>대비(CLAHE)</span><input id="claheClip" type="range" min="1.0" max="6.0" step="0.5" value="3.0" /></label>
          <label><span>샤프닝</span><input id="sharpen" type="range" min="0" max="3" step="1" value="1" /></label>
          <button id="downloadZip" class="btn">ZIP 다운로드</button>
          <button id="resetAll" class="btn danger">초기화</button>
        </div>
        <div class="row" style="width:100%;">
          <progress id="progress" max="100" value="0" aria-label="진행률"></progress>
        </div>
        <div id="status" class="status">준비됨</div>
      </div>
    </section>

    <section class="card">
      <h2>작업 목록</h2>
      <div id="queue" class="queue"></div>
    </section>
  </main>

  <footer class="container footer">
    <span>브라우저에서만 동작 • 서버 전송 없음</span>
  </footer>

  <script>
    const $ = (sel, root=document)=>root.querySelector(sel);
    const $$ = (sel, root=document)=>Array.from(root.querySelectorAll(sel));
    const blobToImageBitmap = (blob)=>createImageBitmap(blob);
    const canvasToBlob = (canvas, type="image/jpeg", quality=0.92)=>new Promise(res=>canvas.toBlob(res, type, quality));
    const fileToArrayBuffer = (file)=>file.arrayBuffer();
    const nameWithSuffix = (name, suffix, ext="jpg")=> name.replace(/\.[^.]+$/, "") + suffix + "." + ext;
    const setStatus = (msg)=>$("#status").textContent = msg;
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  </script>

  <!-- OpenCV 파이프라인 (오검출/과이진화 방지 강화) -->
  <script>
    async function waitForOpenCV(){
      return new Promise(res=>{
        const check=()=>{ (self.cv && cv.Mat) ? res() : setTimeout(check,50); };
        check();
      });
    }

    function safeAdaptiveBinarize(enhanced, useBW){
      if(!useBW){
        return enhanced.clone(); // 컬러(그레이) 유지
      }
      // 1) Otsu로 대략 기준값
      let otsu = new cv.Mat();
      cv.threshold(enhanced, otsu, 0, 255, cv.THRESH_BINARY|cv.THRESH_OTSU);

      // 2) Adaptive로 디테일 살림
      let adap = new cv.Mat();
      cv.adaptiveThreshold(enhanced, adap, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 25, 10);

      // 3) 두 결과 중 더 안정적인 것을 선택 (흑/백 비율로 판정)
      const pick = (m)=>{
        let nz = cv.countNonZero(m);
        let ratioWhite = nz / (m.rows*m.cols); // 0~1
        // 너무 치우쳤으면 불안정
        if (ratioWhite < 0.10 || ratioWhite > 0.90) return null;
        return {mat:m, ratio:ratioWhite};
      };
      let c1 = pick(otsu), c2 = pick(adap);

      let out;
      if (c1 && c2){
        // 0.3~0.7 중심에 가까운 쪽 선택
        const bias = (r)=>Math.abs(r-0.5);
        out = (bias(c1.ratio) <= bias(c2.ratio)) ? otsu : adap;
      } else if (c1) {
        out = otsu;
      } else if (c2) {
        out = adap;
      } else {
        // 이진화가 망한 케이스 → 그레이 유지
        out = enhanced.clone();
      }
      if (out !== otsu) otsu.delete();
      if (out !== adap) adap.delete();
      return out;
    }

    function processImageBitmap(bitmap, opts){
      const {useBW=true, claheClip=3.0, sharpen=1} = opts;

      const canvas=document.createElement("canvas");
      canvas.width=bitmap.width; canvas.height=bitmap.height;
      const ctx=canvas.getContext("2d"); ctx.drawImage(bitmap,0,0);

      let src=cv.imread(canvas);
      let origArea = src.rows * src.cols;

      try{
        // 그레이
        let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);

        // 원근 보정(안전 필터 포함)
        let warped=perspectiveWarpByLargestQuadSafe(gray, origArea);

        // Deskew
        let deskewed=deskewByHough(warped);

        // 조명 보정
        let corrected=illuminationCorrect(deskewed);

        // CLAHE
        let clahe=new cv.Mat(); let cla=new cv.CLAHE(claheClip,new cv.Size(8,8)); cla.apply(corrected,clahe);

        // 샤프닝
        let enhanced=sharpen>0 ? unsharpMask(clahe,sharpen) : clahe.clone();

        // 안전 이진화
        let out = safeAdaptiveBinarize(enhanced, useBW);

        // RGBA로 뿌리기
        let rgba=new cv.Mat();
        if (out.type() === cv.CV_8UC1) cv.cvtColor(out,rgba,cv.COLOR_GRAY2RGBA);
        else cv.cvtColor(out,rgba,cv.COLOR_GRAY2RGBA);
        cv.imshow(canvas, rgba);

        gray.delete(); warped.delete(); deskewed.delete(); corrected.delete(); clahe.delete(); enhanced.delete(); out.delete(); rgba.delete();
        src.delete();
        return canvas;
      }catch(e){
        console.error(e);
        src.delete();
        throw e;
      }
    }

    function perspectiveWarpByLargestQuadSafe(gray, origArea){
      let edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
      let contours=new cv.MatVector(), hierarchy=new cv.Mat();
      cv.findContours(edges,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

      let bestArea=0,best=null,bestHullArea=1;
      for(let i=0;i<contours.size();i++){
        let cnt=contours.get(i);
        let peri=cv.arcLength(cnt,true);
        let approx=new cv.Mat();
        cv.approxPolyDP(cnt,approx,0.02*peri,true);

        if(approx.rows===4){
          let area=cv.contourArea(approx);
          // 컨벡스헐 직사각형성 체크
          let hull=new cv.Mat();
          cv.convexHull(approx, hull, true, true);
          let hullArea=cv.contourArea(hull);
          let rectness = area / Math.max(1, hullArea);

          // 최소 면적(원본의 18% 이상) & 직사각형성(>=0.82) 필터
          if(area > bestArea && area > 0.18*origArea && rectness >= 0.82){
            bestArea = area; best = approx; bestHullArea = hullArea;
          } else {
            approx.delete();
          }
          hull.delete();
        } else {
          approx.delete();
        }
        cnt.delete();
      }

      if (!best){
        edges.delete(); contours.delete(); hierarchy.delete();
        return gray.clone();
      }

      // 점 정렬
      let pts=[];
      for(let r=0;r<4;r++){ pts.push({x:best.intPtr(r,0)[0], y:best.intPtr(r,0)[1]}); }
      best.delete(); edges.delete(); contours.delete(); hierarchy.delete();

      const [p0,p1,p2,p3]=orderQuad(pts);
      const widthA=Math.hypot(p2.x-p3.x,p2.y-p3.y);
      const widthB=Math.hypot(p1.x-p0.x,p1.y-p0.y);
      const heightA=Math.hypot(p1.x-p2.x,p1.y-p2.y);
      const heightB=Math.hypot(p0.x-p3.x,p0.y-p3.y);
      const maxW=Math.max(widthA,widthB), maxH=Math.max(heightA,heightB);

      // 결과 면적이 너무 작으면(원본의 25% 미만) 원근보정 생략
      if ((maxW*maxH) < 0.25*origArea){
        return gray.clone();
      }
      // 극단 비율(초슬림) 회피
      const ar = maxW / Math.max(1, maxH);
      if (ar > 3.5 || ar < 0.25){
        return gray.clone();
      }

      let srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[p0.x,p0.y,p1.x,p1.y,p2.x,p2.y,p3.x,p3.y]);
      let dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,maxW,0,maxW,maxH,0,maxH]);
      let M=cv.getPerspectiveTransform(srcTri,dstTri);

      let warped=new cv.Mat();
      cv.warpPerspective(gray,warped,M,new cv.Size(Math.round(maxW),Math.round(maxH)),cv.INTER_CUBIC,cv.BORDER_REPLICATE);
      srcTri.delete(); dstTri.delete(); M.delete();
      return warped;
    }

    function orderQuad(pts){ pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x); const bottom=pts.slice(2).sort((a,b)=>a.x-b.x); return [top[0],top[1],bottom[1],bottom[0]]; }
    function deskewByHough(gray){
      let edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
      let lines=new cv.Mat(); cv.HoughLines(edges,lines,1,Math.PI/180,200); edges.delete();
      if(!lines || lines.rows===0) return gray.clone();
      let angles=[]; for(let i=0;i<lines.rows;i++){ let deg=lines.data32F[i*2+1]*180/Math.PI; if(deg>45&&deg<135) deg-=90; angles.push(deg); }
      const avg=angles.reduce((a,b)=>a+b,0)/angles.length;
      let center=new cv.Point(gray.cols/2,gray.rows/2);
      let M=cv.getRotationMatrix2D(center,avg,1.0);
      let rotated=new cv.Mat(); cv.warpAffine(gray,rotated,M,new cv.Size(gray.cols,gray.rows),cv.INTER_CUBIC,cv.BORDER_REPLICATE);
      lines.delete(); M.delete(); return rotated;
    }
    function illuminationCorrect(gray){
      let blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(31,31),0);
      let corrected=new cv.Mat(); cv.divide(gray,blur,corrected,255); cv.normalize(corrected,corrected,0,255,cv.NORM_MINMAX);
      blur.delete(); return corrected;
    }
    function unsharpMask(gray,level=1){
      let blurred=new cv.Mat(); cv.GaussianBlur(gray,blurred,new cv.Size(0,0),1.5);
      let sharp=new cv.Mat(); const amount=Math.min(3,Math.max(0,level))*0.6; cv.addWeighted(gray,1+amount,blurred,-amount,0,sharp);
      blurred.delete(); return sharp;
    }
  </script>

  <!-- 앱 로직 (자동보정 + HEIC 대응) -->
  <script>
    const queueEl=$("#queue"), fileInput=$("#fileInput"), dropzone=$("#dropzone");
    const btnDownloadZip=$("#downloadZip"), btnResetAll=$("#resetAll");
    const bar=$("#progress");
    let items=[]; let processing=false;

    async function handleFiles(files){
      try{
        setStatus("파일을 읽는 중…");
        const list = Array.from(files);
        for (const f of list){
          const name = (f.name || "untitled").toLowerCase();
          const mime = (f.type || "");
          const isPdf  = mime === "application/pdf" || name.endsWith(".pdf");
          const isHeic = name.endsWith(".heic") || name.endsWith(".heif") || mime === "image/heic" || mime === "image/heif";
          const isImg  = mime.startsWith("image/") || /\.(jpg|jpeg|png|bmp|gif|webp|tif|tiff)$/i.test(name);

          if (isPdf){
            await enqueuePdf(f);
          } else if (isHeic){
            try {
              const ab  = await f.arrayBuffer();
              const src = new Blob([ab], { type: "image/heic" });
              const jpgBlob = await heic2any({ blob: src, toType: "image/jpeg", quality: 0.95 });
              await enqueueImage(jpgBlob, name.replace(/\.(heic|heif)$/i, ".jpg"));
            } catch (err){
              console.error("HEIC 변환 실패:", err);
              setStatus("HEIC 변환 실패 — PNG로 다시 시도해 주세요");
            }
          } else if (isImg){
            await enqueueImage(f, f.name);
          } else {
            console.warn("지원하지 않는 형식:", f.name, mime);
            setStatus("지원하지 않는 형식이 포함되어 있습니다");
          }
          await sleep(5);
        }
        if (fileInput) fileInput.value = "";
        setStatus("자동 보정 시작…");
        autoProcess();
      }catch(err){
        console.error(err);
        setStatus("업로드 중 오류");
      }
    }

    async function enqueueImage(blob, name){
      const url=URL.createObjectURL(blob);
      const item={ name, originalBlob:blob, processedBlob:null };
      const el=document.createElement("div");
      el.className="item";
      el.innerHTML=`
        <div class="thumb"><img src="${url}" alt="${name}"></div>
        <div class="meta"><span>${name}</span><span class="badge">대기</span></div>
        <div class="actions">
          <button class="btn doDownload" disabled>다운로드</button>
        </div>
      `;
      $(".doDownload",el).addEventListener("click",()=>downloadOne(item));
      item.el=el; items.push(item); queueEl.append(el);
    }

    async function enqueuePdf(file){
      const buf=await fileToArrayBuffer(file);
      const pdf=await pdfjsLib.getDocument({ data: buf }).promise;
      for(let p=1;p<=pdf.numPages;p++){
        setStatus(`PDF 렌더링 (${p}/${pdf.numPages})`);
        const page=await pdf.getPage(p);
        const viewport=page.getViewport({ scale: 2.0 });
        const canvas=document.createElement("canvas");
        canvas.width=viewport.width; canvas.height=viewport.height;
        const ctx=canvas.getContext("2d");
        await page.render({ canvasContext: ctx, viewport }).promise;
        const blob=await new Promise(res=>canvas.toBlob(res,"image/jpeg",0.95));
        await enqueueImage(blob, `${file.name.replace(/\.pdf$/i,"")}_p${p}.jpg`);
        await sleep(10);
      }
    }

    async function processOne(item){
      const el=item.el; const badge=$(".badge",el); const btn=$(".doDownload",el);
      badge.textContent="보정 중…";
      await waitForOpenCV();
      const bitmap=await blobToImageBitmap(item.originalBlob);
      const opts={ useBW: $("#useBW").checked, claheClip: parseFloat($("#claheClip").value), sharpen: parseInt($("#sharpen").value,10) };
      const canvas=processImageBitmap(bitmap, opts);
      const outBlob=await canvasToBlob(canvas, "image/jpeg", 0.95);
      item.processedBlob=outBlob; $(".thumb img", el).src=URL.createObjectURL(outBlob);
      badge.textContent="완료"; btn.disabled=false;
    }

    async function autoProcess(){
      if(processing) return; processing=true;
      try{
        let total=items.length, done=0; bar.max=total||1; bar.value=0;
        for(const it of items){
          if(!it.processedBlob){ setStatus(`보정 중: ${it.name}`); await processOne(it); }
          done++; bar.value=done;
        }
        setStatus("전체 자동 보정 완료");
      }catch(err){ console.error(err); setStatus("보정 중 오류 발생"); }
      finally{ processing=false; }
    }

    async function downloadOne(item){
      const blob=item.processedBlob || item.originalBlob;
      const a=document.createElement("a"); a.href=URL.createObjectURL(blob);
      a.download=item.processedBlob ? nameWithSuffix(item.name, "_fixed") : item.name;
      document.body.appendChild(a); a.click(); a.remove();
    }

    $("#downloadZip").addEventListener("click", async ()=>{
      const zip=new JSZip(); let count=0;
      for(const item of items){
        const blob=item.processedBlob || item.originalBlob;
        const name=item.processedBlob ? nameWithSuffix(item.name,"_fixed") : item.name;
        zip.file(name, await blob.arrayBuffer()); count++;
      }
      const content=await zip.generateAsync({ type:"blob" });
      saveAs(content, "vflat-lite-output.zip"); setStatus(`ZIP 다운로드 생성 (${count}개 항목)`);
    });

    $("#resetAll").addEventListener("click", ()=>{
      items=[]; $("#queue").innerHTML=""; $("#progress").value=0; $("#progress").max=100; setStatus("초기화됨");
    });

    $("#dropzone").addEventListener("click", ()=>$("#fileInput").click());
    $("#fileInput").addEventListener("change", (e)=>handleFiles(e.target.files));
    $("#dropzone").addEventListener("dragover", (e)=>{ e.preventDefault(); $("#dropzone").classList.add("drag"); });
    $("#dropzone").addEventListener("dragleave", ()=>$("#dropzone").classList.remove("drag"));
    $("#dropzone").addEventListener("drop", (e)=>{ e.preventDefault(); $("#dropzone").classList.remove("drag"); if(e.dataTransfer && e.dataTransfer.files) handleFiles(e.dataTransfer.files); });

    setStatus("준비됨");
  </script>
</body>
</html>
