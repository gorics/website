<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>vFlat Lite — 자동 보정</title>
  <meta name="description" content="이미지/PDF를 브라우저에서 자동 원근/기울기/조명/대비 보정합니다."/>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><rect width='128' height='128' rx='24' fill='%2360a5fa'/><path d='M30 84c16-32 52-32 68 0' stroke='%230b0c10' stroke-width='10' fill='none' stroke-linecap='round'/><circle cx='44' cy='48' r='6' fill='%230b0c10'/><circle cx='84' cy='48' r='6' fill='%230b0c10'/></svg>" type="image/svg+xml">

  <!-- OpenCV.js -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.worker.min.js";</script>
  <!-- HEIC → JPEG 변환 -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <!-- JSZip & FileSaver (ZIP 내보내기) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
    :root{
      --bg:#0b0c10; --fg:#e5e7eb; --muted:#94a3b8; --card:#111827; --accent:#60a5fa; --danger:#ef4444;
      --border:#1f2937;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
    .container{max-width:1100px;margin:0 auto;padding:16px}
    header h1{margin:0 0 4px 0}
    .subtitle{color:var(--muted);margin:0 0 12px 0}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:16px}
    .dropzone{border:2px dashed var(--border);border-radius:12px;padding:24px;text-align:center;color:var(--muted);cursor:pointer;position:relative}
    .dropzone.drag{border-color:var(--accent);color:var(--fg)}
    .dropzone input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer}
    .controls .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin:8px 0}
    .controls label{display:flex;flex-direction:column;font-size:14px;color:var(--muted)}
    .controls .btn{padding:10px 14px;border:1px solid var(--border);border-radius:10px;background:#0f172a;color:var(--fg);cursor:pointer}
    .controls .btn.primary{background:var(--accent);border-color:transparent;color:#0b0c10;font-weight:600}
    .controls .btn.danger{background:var(--danger);border-color:transparent;color:white}
    .controls .status{margin-top:8px;color:var(--muted);font-size:13px}
    .queue{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .item{background:#0f172a;border:1px solid var(--border);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px}
    .item .thumb{width:100%;aspect-ratio:3/4;background:#111;border-radius:8px;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .item img{max-width:100%}
    .item .meta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;gap:6px}
    .item .actions{display:flex;gap:8px}
    .item .actions .btn{flex:1;text-align:center;padding:8px;border-radius:8px;border:1px solid var(--border);background:#0b1220;color:var(--fg)}
    .footer{color:var(--muted);font-size:12px;text-align:center;margin-bottom:24px}
    progress{width:100%; height:10px; border-radius:6px; background:#0b1220}
  </style>
</head>
<body>
  <header class="container">
    <h1>vFlat Lite</h1>
    <p class="subtitle">GitHub Pages용 • 업로드하면 자동 보정 시작</p>
  </header>

  <main class="container">
    <section class="card">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="업로드 영역">
        <div><strong>이미지(JPG/PNG/HEIC) 또는 PDF</strong>를 끌어놓거나 눌러서 업로드하세요.</div>
        <input id="fileInput"
               type="file"
               accept="image/*,application/pdf,.pdf,.heic,.heif,.jpg,.jpeg,.png"
               multiple />
      </div>

      <div class="controls">
        <div class="row">
          <label><span>자동 흑백(Adaptive)</span><input id="useBW" type="checkbox" checked /></label>
          <label><span>대비(CLAHE)</span><input id="claheClip" type="range" min="1.0" max="6.0" step="0.5" value="3.0" /></label>
          <label><span>샤프닝</span><input id="sharpen" type="range" min="0" max="3" step="1" value="1" /></label>
          <button id="downloadZip" class="btn">ZIP 다운로드</button>
          <button id="resetAll" class="btn danger">초기화</button>
        </div>
        <div class="row" style="width:100%;">
          <progress id="progress" max="100" value="0" aria-label="진행률"></progress>
        </div>
        <div id="status" class="status">준비됨</div>
      </div>
    </section>

    <section class="card">
      <h2>작업 목록</h2>
      <div id="queue" class="queue"></div>
    </section>
  </main>

  <footer class="container footer">
    <span>브라우저에서만 동작 • 서버 전송 없음</span>
  </footer>

  <!-- utils -->
  <script>
    const $ = (sel, root=document)=>root.querySelector(sel);
    const $$ = (sel, root=document)=>Array.from(root.querySelectorAll(sel));
    const blobToImageBitmap = (blob)=>createImageBitmap(blob);
    const canvasToBlob = (canvas, type="image/jpeg", quality=0.92)=>new Promise(res=>canvas.toBlob(res, type, quality));
    const fileToArrayBuffer = (file)=>file.arrayBuffer();
    const nameWithSuffix = (name, suffix, ext="jpg")=> name.replace(/\.[^.]+$/, "") + suffix + "." + ext;
    const setStatus = (msg)=>$("#status").textContent = msg;
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  </script>

  <!-- OpenCV 파이프라인 -->
  <script>
    async function waitForOpenCV(){
      return new Promise(res=>{
        const check=()=>{ (self.cv && cv.Mat) ? res() : setTimeout(check,50); };
        check();
      });
    }

    function processImageBitmap(bitmap, opts){
      const {useBW=true, claheClip=3.0, sharpen=1} = opts;
      const canvas=document.createElement("canvas");
      canvas.width=bitmap.width; canvas.height=bitmap.height;
      const ctx=canvas.getContext("2d"); ctx.drawImage(bitmap,0,0);
      let src=cv.imread(canvas);

      try{
        let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);

        let warped=perspectiveWarpByLargestQuad(gray);
        let deskewed=deskewByHough(warped);
        let corrected=illuminationCorrect(deskewed);

        let clahe=new cv.Mat(); let cla=new cv.CLAHE(claheClip,new cv.Size(8,8)); cla.apply(corrected,clahe);

        let enhanced=sharpen>0 ? unsharpMask(clahe,sharpen) : clahe.clone();

        let out=new cv.Mat();
        if(useBW){
          cv.adaptiveThreshold(enhanced,out,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,25,10);
        } else {
          out=enhanced.clone();
        }

        let rgba=new cv.Mat(); cv.cvtColor(out,rgba,cv.COLOR_GRAY2RGBA);
        cv.imshow(canvas,rgba);

        gray.delete(); warped.delete(); deskewed.delete(); corrected.delete(); clahe.delete(); enhanced.delete(); out.delete(); rgba.delete();
        src.delete();
        return canvas;
      }catch(e){
        console.error(e);
        src.delete();
        throw e;
      }
    }

    function perspectiveWarpByLargestQuad(gray){
      let edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
      let contours=new cv.MatVector(), hierarchy=new cv.Mat();
      cv.findContours(edges,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

      let bestArea=0,best=null;
      for(let i=0;i<contours.size();i++){
        let cnt=contours.get(i);
        let peri=cv.arcLength(cnt,true);
        let approx=new cv.Mat();
        cv.approxPolyDP(cnt,approx,0.02*peri,true);
        if(approx.rows===4){
          let area=cv.contourArea(approx);
          if(area>bestArea){ bestArea=area; best=approx; } else { approx.delete(); }
        }else{
          approx.delete();
        }
        cnt.delete();
      }

      if(!best){
        edges.delete(); contours.delete(); hierarchy.delete();
        return gray.clone();
      }

      let pts=[];
      for(let r=0;r<4;r++){ pts.push({x:best.intPtr(r,0)[0], y:best.intPtr(r,0)[1]}); }
      best.delete(); edges.delete(); contours.delete(); hierarchy.delete();

      const [p0,p1,p2,p3]=orderQuad(pts);
      const maxW=Math.max(Math.hypot(p2.x-p3.x,p2.y-p3.y), Math.hypot(p1.x-p0.x,p1.y-p0.y));
      const maxH=Math.max(Math.hypot(p1.x-p2.x,p1.y-p2.y), Math.hypot(p0.x-p3.x,p0.y-p3.y));

      let srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[p0.x,p0.y,p1.x,p1.y,p2.x,p2.y,p3.x,p3.y]);
      let dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,maxW,0,maxW,maxH,0,maxH]);
      let M=cv.getPerspectiveTransform(srcTri,dstTri);

      let warped=new cv.Mat();
      cv.warpPerspective(gray,warped,M,new cv.Size(Math.round(maxW),Math.round(maxH)),cv.INTER_CUBIC,cv.BORDER_REPLICATE);

      srcTri.delete(); dstTri.delete(); M.delete();
      return warped;
    }

    function orderQuad(pts){
      pts.sort((a,b)=>a.y-b.y);
      const top=pts.slice(0,2).sort((a,b)=>a.x-b.x);
      const bottom=pts.slice(2).sort((a,b)=>a.x-b.x);
      return [top[0],top[1],bottom[1],bottom[0]]; // tl, tr, br, bl
    }

    function deskewByHough(gray){
      let edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
      let lines=new cv.Mat(); cv.HoughLines(edges,lines,1,Math.PI/180,200);
      edges.delete();
      if(!lines || lines.rows===0){ return gray.clone(); }

      let angles=[];
      for(let i=0;i<lines.rows;i++){
        let theta=lines.data32F[i*2+1];
        let deg=theta*180/Math.PI;
        if(deg>45 && deg<135) deg-=90;
        angles.push(deg);
      }
      const avg=angles.reduce((a,b)=>a+b,0)/angles.length;

      let center=new cv.Point(gray.cols/2,gray.rows/2);
      let M=cv.getRotationMatrix2D(center,avg,1.0);
      let rotated=new cv.Mat();
      cv.warpAffine(gray,rotated,M,new cv.Size(gray.cols,gray.rows),cv.INTER_CUBIC,cv.BORDER_REPLICATE);
      lines.delete(); M.delete();
      return rotated;
    }

    function illuminationCorrect(gray){
      let blur=new cv.Mat();
      cv.GaussianBlur(gray,blur,new cv.Size(31,31),0);
      let corrected=new cv.Mat();
      cv.divide(gray,blur,corrected,255);
      cv.normalize(corrected,corrected,0,255,cv.NORM_MINMAX);
      blur.delete();
      return corrected;
    }

    function unsharpMask(gray,level=1){
      let blurred=new cv.Mat();
      cv.GaussianBlur(gray,blurred,new cv.Size(0,0),1.5);
      let sharp=new cv.Mat();
      const amount=Math.min(3,Math.max(0,level))*0.6;
      cv.addWeighted(gray,1+amount,blurred,-amount,0,sharp);
      blurred.delete();
      return sharp;
    }
  </script>

  <!-- 앱 로직 (자동보정 + HEIC 대응) -->
  <script>
    const queueEl=$("#queue"), fileInput=$("#fileInput"), dropzone=$("#dropzone");
    const btnDownloadZip=$("#downloadZip"), btnResetAll=$("#resetAll");
    const bar=$("#progress");
    let items=[]; // { name, originalBlob, processedBlob, el }
    let processing=false;

    async function handleFiles(files){
      try{
        setStatus("파일을 읽는 중…");
        const list = Array.from(files);

        for (const f of list){
          const name = (f.name || "untitled").toLowerCase();
          const mime = (f.type || "");

          const isPdf  = mime === "application/pdf" || name.endsWith(".pdf");
          const isHeic = name.endsWith(".heic") || name.endsWith(".heif") || mime === "image/heic" || mime === "image/heif";
          const isImg  = mime.startsWith("image/") || /\.(jpg|jpeg|png|bmp|gif|webp|tif|tiff)$/i.test(name);

          if (isPdf){
            await enqueuePdf(f);
          } else if (isHeic){
            try {
              const ab  = await f.arrayBuffer();
              const src = new Blob([ab], { type: "image/heic" });
              const jpgBlob = await heic2any({ blob: src, toType: "image/jpeg", quality: 0.95 });
              await enqueueImage(jpgBlob, name.replace(/\.(heic|heif)$/i, ".jpg"));
            } catch (err){
              console.error("HEIC 변환 실패:", err);
              setStatus("HEIC 변환 실패 — PNG로 다시 시도해 주세요");
            }
          } else if (isImg){
            await enqueueImage(f, f.name);
          } else {
            console.warn("지원하지 않는 형식:", f.name, mime);
            setStatus("지원하지 않는 형식이 포함되어 있습니다");
          }
          await sleep(5);
        }

        // 같은 파일 재선택 허용
        if (fileInput) fileInput.value = "";

        setStatus("자동 보정 시작…");
        autoProcess();
      }catch(err){
        console.error(err);
        setStatus("업로드 중 오류");
      }
    }

    async function enqueueImage(blob, name){
      const url=URL.createObjectURL(blob);
      const item={ name, originalBlob:blob, processedBlob:null };
      const el=document.createElement("div");
      el.className="item";
      el.innerHTML=`
        <div class="thumb"><img src="${url}" alt="${name}"></div>
        <div class="meta"><span>${name}</span><span class="badge">대기</span></div>
        <div class="actions">
          <button class="btn doDownload" disabled>다운로드</button>
        </div>
      `;
      $(".doDownload",el).addEventListener("click",()=>downloadOne(item));
      item.el=el;
      items.push(item);
      queueEl.append(el);
    }

    async function enqueuePdf(file){
      const buf=await fileToArrayBuffer(file);
      const pdf=await pdfjsLib.getDocument({ data: buf }).promise;
      for(let p=1;p<=pdf.numPages;p++){
        setStatus(`PDF 렌더링 (${p}/${pdf.numPages})`);
        const page=await pdf.getPage(p);
        const viewport=page.getViewport({ scale: 2.0 });
        const canvas=document.createElement("canvas");
        canvas.width=viewport.width; canvas.height=viewport.height;
        const ctx=canvas.getContext("2d");
        await page.render({ canvasContext: ctx, viewport }).promise;
        const blob=await new Promise(res=>canvas.toBlob(res,"image/jpeg",0.95));
        await enqueueImage(blob, `${file.name.replace(/\.pdf$/i,"")}_p${p}.jpg`);
        await sleep(10);
      }
    }

    async function processOne(item){
      const el=item.el;
      const badge=$(".badge",el);
      const btn=$(".doDownload",el);
      badge.textContent="보정 중…";

      await waitForOpenCV();
      const bitmap=await blobToImageBitmap(item.originalBlob);

      const opts={
        useBW: $("#useBW").checked,
        claheClip: parseFloat($("#claheClip").value),
        sharpen: parseInt($("#sharpen").value,10)
      };
      const canvas=processImageBitmap(bitmap, opts);
      const outBlob=await canvasToBlob(canvas, "image/jpeg", 0.95);

      item.processedBlob=outBlob;
      $(".thumb img", el).src=URL.createObjectURL(outBlob);
      badge.textContent="완료";
      btn.disabled=false;
    }

    async function autoProcess(){
      if(processing) return;
      processing=true;
      try{
        let total=items.length, done=0;
        bar.max=total || 1; bar.value=0;
        for(const it of items){
          if(!it.processedBlob){
            setStatus(`보정 중: ${it.name}`);
            await processOne(it);
          }
          done++; bar.value=done;
        }
        setStatus("전체 자동 보정 완료");
      }catch(err){
        console.error(err);
        setStatus("보정 중 오류 발생");
      }finally{
        processing=false;
      }
    }

    async function downloadOne(item){
      const blob=item.processedBlob || item.originalBlob;
      const a=document.createElement("a");
      a.href=URL.createObjectURL(blob);
      a.download=item.processedBlob ? nameWithSuffix(item.name, "_fixed") : item.name;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    btnDownloadZip.addEventListener("click", async ()=>{
      const zip=new JSZip();
      let count=0;
      for(const item of items){
        const blob=item.processedBlob || item.originalBlob;
        const name=item.processedBlob ? nameWithSuffix(item.name,"_fixed") : item.name;
        zip.file(name, await blob.arrayBuffer());
        count++;
      }
      const content=await zip.generateAsync({ type:"blob" });
      saveAs(content, "vflat-lite-output.zip");
      setStatus(`ZIP 다운로드 생성 (${count}개 항목)`);
    });

    btnResetAll.addEventListener("click", ()=>{
      items=[];
      $("#queue").innerHTML="";
      $("#progress").value=0; $("#progress").max=100;
      setStatus("초기화됨");
    });

    // 업로드 트리거
    $("#dropzone").addEventListener("click", ()=>$("#fileInput").click());
    $("#fileInput").addEventListener("change", (e)=>handleFiles(e.target.files));

    // DnD
    $("#dropzone").addEventListener("dragover", (e)=>{ e.preventDefault(); $("#dropzone").classList.add("drag"); });
    $("#dropzone").addEventListener("dragleave", ()=>$("#dropzone").classList.remove("drag"));
    $("#dropzone").addEventListener("drop", (e)=>{
      e.preventDefault();
      $("#dropzone").classList.remove("drag");
      if(e.dataTransfer && e.dataTransfer.files) handleFiles(e.dataTransfer.files);
    });

    setStatus("준비됨");
  </script>
</body>
</html>
